<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Rapid Suitability (MCDA-lite) — Strathcona County</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="icon" href="data:,">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    :root { --panel-w: 320px; --fs: 11px; }
    html, body { height:100%; margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto; font-size:var(--fs); }
    #app { display:grid; grid-template-columns:1fr var(--panel-w); grid-template-rows:100vh; width:100vw; overflow:hidden; }
    #map { min-width:0; height:100%; }
    #panel {
      height:100%; overflow:auto; padding:8px 10px; border-left:1px solid #ddd; background:#fff; line-height:1.32; z-index:10000;
      display:flex; flex-direction:column;
    }
    h2 { font-size:12px; margin:2px 0 8px; }
    .small { color:#555; font-size:10px; }
    .group { margin:8px 0; }
    label { display:block; margin-bottom:4px; font-weight:600; }
    .row { display:flex; gap:6px; align-items:center; }
    input[type="range"] { width:100%; }
    select, input[type="checkbox"] { font-size:var(--fs); }
    .btn { display:inline-block; padding:5px 5px; background:#016797; color:#fff; border-radius:7px; cursor:pointer; text-decoration:none; }
    .badge { font-size:11px; background:#f0f0f0; padding:1px 5px; border-radius:999px; }
    .muted { color:#777; } .ok { color:#0a7; } .warn { color:#d70; } .err { color:#d33; }
    .hr { height:1px; background:#eee; margin:8px 0; }
    .legend { display:flex; height:10px; margin:4px 0 6px; background:linear-gradient(90deg,#fff7bf,#79bcd7,#0b3c73); border:1px solid #ccc; }
    .footer { margin-top:auto; padding-top:8px; border-top:1px dashed #e5e5e5; }
    /* tighter layers list */
    .layers-list label { display:block; margin:0; line-height:1.2; }
    .layers-list label + label { margin-top:2px; }
    .leaflet-control-layers { display: none !important; }
    .npri-label{
      background: rgba(255,255,255,0.9);
      padding: 1px 3px;
      border: 1px solid #bbb;
      border-radius: 3px;
      box-shadow: 0 1px 1px rgba(0,0,0,0.05);
      font-size: 11px;
    }
  </style>
</head>
<body>
  
<div id="app">
  <div id="map"></div>

  <aside id="panel">
    <h2>Rapid Suitability (MCDA-lite)</h2>
    <div class="small">Hex-grid scoring from live ArcGIS GeoJSON. Adjust and click <b>Recompute</b>.</div>

    <div class="group">
      <a id="btnClear" class="btn" style="background:#6c757d">Clear results</a>
    </div>

    <div class="group">
      <label>Objective</label>
      <select id="mode">
        <option value="exposure">Population/Exposure (closer to amenities)</option>
        <option value="background">Background/Regional (farther from amenities)</option>
      </select>
    </div>
    
    <div class="row"><span class="small" style="width:110px">Pop. density</span>
      <input type="range" id="w_pop" min="0" max="1" step="0.05" value="0.15">
      <span id="w_pop_val" class="badge">0.15</span>
    </div>

    <div class="group">
      <label>Roads preference</label>
      <select id="roadsPref">
        <option value="closer">Closer is better (near traffic)</option>
        <option value="farther">Farther is better (background)</option>
      </select>
    </div>

    <div class="group">
      <label>Hex cell size (km)</label>
      <div class="row">
        <input type="range" id="cellkm" min="0.3" max="2.5" step="0.1" value="0.6">
        <span id="cellkm_val" class="badge">0.6</span>
      </div>
    </div>

    <div class="group">
      <label>Distance cap for proximity (km) <span class="small">(linear rescale)</span></label>
      <div class="row">
        <input type="range" id="dmax" min="0.5" max="6" step="0.5" value="3">
        <span id="dmax_val" class="badge">3</span>
      </div>
    </div>

    <div class="group">
      <label>Weights (auto-normalize)</label>
      <div class="row"><span class="small" style="width:110px">Wi-Fi proximity</span><input type="range" id="w_wifi" min="0" max="1" step="0.05" value="0.25"><span id="w_wifi_val" class="badge">0.25</span></div>
      <div class="row"><span class="small" style="width:110px">Amenities proximity</span><input type="range" id="w_amen" min="0" max="1" step="0.05" value="0.25"><span id="w_amen_val" class="badge">0.25</span></div>
      <div class="row"><span class="small" style="width:110px">Roads proximity</span><input type="range" id="w_road" min="0" max="1" step="0.05" value="0.20"><span id="w_road_val" class="badge">0.20</span></div>
      <div class="row"><span class="small" style="width:110px">Land-use score</span><input type="range" id="w_lu" min="0" max="1" step="0.05" value="0.20"><span id="w_lu_val" class="badge">0.20</span></div>
      <div class="row"><span class="small" style="width:110px">Bldg density</span><input type="range" id="w_bld" min="0" max="1" step="0.05" value="0.10"><span id="w_bld_val" class="badge">0.10</span></div>
      <div class="small muted">Sum is normalized to 1.</div>
    </div>

    <div class="group">
      <label><input type="checkbox" id="excludePEMU"> Exclude inside Priority Environmental Mgmt Units</label>
    </div>

    <!-- LAYERS: click on/off -->
    <div class="group">
      <label>Layers (click to show/hide)</label>
      <div class="layers-list small">
        <label><input type="checkbox" id="toggleHex" checked> Suitability hexes</label>
        <label><input type="checkbox" id="toggleTop" checked> Top 10 candidates</label>
        <label><input type="checkbox" id="toggleWifi"> Buildings with Wi-Fi</label>
        <label><input type="checkbox" id="togglePlay"> Playgrounds</label>
        <label><input type="checkbox" id="toggleParks"> Parks</label>
        <label><input type="checkbox" id="toggleFields"> Playing Fields</label>
        <label><input type="checkbox" id="toggleSplash"> Splash Parks</label>
        <label><input type="checkbox" id="toggleRoads"> Roads</label>
        <label><input type="checkbox" id="toggleBldg"> Building footprints</label>
        <label><input type="checkbox" id="togglePEMU"> Priority Env. Mgmt Units</label>
        <label><input type="checkbox" id="toggleLand"> Land-use polygons</label>
        <label><input type="checkbox" id="toggleNPRIwms"> NPRI — Facilities (WMS)</label>
        <label><input type="checkbox" id="togglePA"> PurpleAir sensors</label>
        <label><input type="checkbox" id="toggleStations"> AQ stations</label>
        <label><input type="checkbox" id="toggleCensus"> 2018 Census population density</label>
        <div id="censusStats" class="small panel">Loading…</div>
      </div>
    </div>

    
    <!-- Land-use score legend/explanation -->
    <div class="group small">
      <b>Land-use score mapping</b>
      <table style="font-size:11px;border-collapse:collapse;margin-top:4px">
        <tr><td>Industrial (IND)</td><td style="padding-left:8px">0.90</td></tr>
        <tr><td>Commercial (COM)</td><td style="padding-left:8px">0.80</td></tr>
        <tr><td>Institutional (INS)</td><td style="padding-left:8px">0.75</td></tr>
        <tr><td>Residential (RES)</td><td style="padding-left:8px">0.60</td></tr>
        <tr><td>Park / Open Space</td><td style="padding-left:8px">0.40</td></tr>
        <tr><td>Agriculture</td><td style="padding-left:8px">0.50</td></tr>
        <tr><td>Default/Other</td><td style="padding-left:8px">0.50</td></tr>
      </table>
    </div>

    <div class="group">
      <a id="runBtn" class="btn">Recompute</a>
      <span id="status" class="small muted">Loading data…</span>
    </div>

    <div class="group">
      <button id="btnExportMCDA" class="btn">Download Top 10 (CSV)</button>
      <span class="small muted" style="display:block;margin-top:4px">
        Exports Top 10 + parameters & component values
      </span>
    </div>

    <div class="group">
      <div class="small"><b>Legend</b> (low → high)</div>
      <div class="legend"></div>
    </div>

    <div class="hr"></div>
    <div class="small">
      Notes: Uses Wi-Fi bldgs, amenities (Playgrounds, Parks, Playing Fields, Splash Parks), Roads, Land-Use, and Building Footprints. Contours are ignored (no slope inference here).
    </div>

    <div class="footer small">
      <b>Land-use score here:</b> <span id="lu_readout">—</span>
    </div>
  </aside>
</div>

<!-- stations data helpers -->
<script src="data.js"></script>

<script>
/* ------------------------- CONFIG / LAYERS ------------------------- */
const URLS = {
  wifi:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/County_Buildings_with_WiFi/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  play:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Playgrounds/FeatureServer/3/query?outFields=*&where=1%3D1&f=geojson',
  parks: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Parks/FeatureServer/2/query?outFields=*&where=1%3D1&f=geojson',
  fields:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Playing_Fields/FeatureServer/5/query?outFields=*&where=1%3D1&f=geojson',
  splash:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Splash_Parks/FeatureServer/8/query?outFields=*&where=1%3D1&f=geojson',
  bldg:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Building_Footprints/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',  // RESTORE
  roads: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Street_Network1/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',     // RESTORE
  pemu:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Priority_Environment_Management_Units/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  land: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Land_Use_Bylaw/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson'
};
const LAYER_URLS = { purpleair: 'https://raw.githubusercontent.com/DKevinM/AB_datapull/main/data/ACA_PM25_map.json' };


let npriLayer = null;
let npriMoveHandler = null;
let npriTip = null;

function getFeatureInfoUrl(layer, latlng) {
  const point = map.latLngToContainerPoint(latlng, map.getZoom());
  const size = map.getSize();
  const base = layer._url;
  const params = {
    request: 'GetFeatureInfo',
    service: 'WMS',
    version: layer.wmsParams.version || '1.3.0',
    styles: layer.wmsParams.styles || '',
    transparent: true,
    format: 'image/png',
    bbox: map.getBounds().toBBoxString(),
    height: size.y,
    width: size.x,
    layers: layer.wmsParams.layers,
    query_layers: layer.wmsParams.layers,
    info_format: 'application/json' // try JSON first; many servers support it
  };
  // Pixel coords param names change between 1.1.1 and 1.3.0
  params[params.version === '1.3.0' ? 'i' : 'x'] = Math.round(point.x);
  params[params.version === '1.3.0' ? 'j' : 'y'] = Math.round(point.y);
  return base + L.Util.getParamString(params, base, true);
}

function startNpriHover() {
  if (npriLayer) return;

  npriLayer = L.tileLayer.wms(NPRI_WMS_URL, {
    layers: NPRI_WMS_LAYERS,
    format: 'image/png',
    transparent: true,
    version: '1.3.0'
  }).addTo(map);

  npriTip = L.tooltip({
    sticky: true,
    direction: 'top',
    offset: [0, -6],
    className: 'npri-label'
  });

  // simple debounce so we don't hammer the server
  let tId = null;
  npriMoveHandler = (e) => {
    if (tId) clearTimeout(tId);
    tId = setTimeout(async () => {
      try {
        const url = getFeatureInfoUrl(npriLayer, e.latlng);
        const res = await fetch(url);
        if (!res.ok) throw new Error('GetFeatureInfo failed');
        const data = await res.json();

        // Try to find a feature and a few common NPRI fields
        const feat = (data.features && data.features[0]) || null;
        const props = feat?.properties || {};
        const name =
          props.FACILITY_NA || props.FACILITY_NAME || props.NAME || props.Name || 'NPRI Facility';
        const comp =
          props.COMPANY_NA || props.COMPANY || props.OWNER || '';
        const city =
          props.CITY || props.MUNICIPALITY || props.MUNICIPAL || '';
        const naics = props.NAICS || props.NAICS_CODE || '';
        
        if (feat) {
          const html = `<b>${name}</b>${comp ? `<div>${comp}</div>` : ''}${
            city ? `<div>${city}</div>` : ''
          }${naics ? `<div>NAICS: ${naics}</div>` : ''}`;
          npriTip.setContent(html);
          npriTip.setLatLng(e.latlng);
          if (!npriTip._map) npriTip.addTo(map);
        } else {
          if (npriTip._map) map.removeLayer(npriTip);
        }
      } catch {
        if (npriTip?._map) map.removeLayer(npriTip);
      }
    }, 120);
  };

  map.on('mousemove', npriMoveHandler);
}

function stopNpriHover() {
  if (npriMoveHandler) map.off('mousemove', npriMoveHandler);
  npriMoveHandler = null;
  if (npriTip && npriTip._map) map.removeLayer(npriTip);
  npriTip = null;
  if (npriLayer) { map.removeLayer(npriLayer); npriLayer = null; }
}





  
  
/* --------------------------- START APP ---------------------------- */
window.addEventListener('DOMContentLoaded', () => {
  /* -------- MAP (create ONCE) -------- */
  const map = L.map('map', { zoomControl:true }).setView([53.53, -113.30], 12);
  window.map = map; // expose the Leaflet map to other scripts
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20}).addTo(map);
  
  // after your tile layer is added
  window.layersControl = L.control.layers(null, null, { collapsed: true }).addTo(map);
  
  // Panes: tiles (200) < features (400) < suitability (410) < markers (420)
  map.createPane('features');    map.getPane('features').style.zIndex = 400;
  map.createPane('suitability'); map.getPane('suitability').style.zIndex = 410;
  map.createPane('markers');     map.getPane('markers').style.zIndex = 420;

  setTimeout(()=>map.invalidateSize(),0);
  window.addEventListener('resize',()=>map.invalidateSize());

  // remember last MCDA results so we can export later
  window.lastMCDA = null;

  
  /* -------- UI refs -------- */
  const ui = {
    mode: mode,
    roadsPref: roadsPref,
    cellkm: cellkm, cellkm_val: cellkm_val,
    dmax: dmax, dmax_val: dmax_val,
    w_wifi: w_wifi, w_wifi_val: w_wifi_val,
    w_amen: w_amen, w_amen_val: w_amen_val,
    w_road: w_road, w_road_val: w_road_val,
    w_lu: w_lu, w_lu_val: w_lu_val,
    w_bld: w_bld, w_bld_val: w_bld_val,
    w_pop: w_pop, w_pop_val: w_pop_val,
    excludePEMU: excludePEMU,
    togglePA: togglePA,
    toggleStations: toggleStations,
    toggleHex: toggleHex,
    toggleTop: toggleTop,
    toggleWifi: toggleWifi,
    togglePlay: togglePlay,
    toggleParks: toggleParks,
    toggleFields: toggleFields,
    toggleSplash: toggleSplash,
    toggleRoads: toggleRoads,
    toggleBldg: toggleBldg,
    togglePEMU: togglePEMU,
    toggleLand: toggleLand,
    toggleNPRIwms: toggleNPRIwms,
    runBtn: runBtn,
    status: status,
    lu_readout: lu_readout,
    btnClear: btnClear,
  };
  function hookRange(inp, lab){ const f=()=>lab.textContent=(+inp.value).toFixed(inp.step.includes('.')?1:0); inp.addEventListener('input',f); f(); }
  [['cellkm','cellkm_val'],['dmax','dmax_val'],['w_wifi','w_wifi_val'],['w_amen','w_amen_val'],['w_road','w_road_val'],['w_lu','w_lu_val'],['w_bld','w_bld_val'],['w_pop','w_pop_val']].forEach(([a,b])=>hookRange(ui[a],ui[b]));
  
  
  // (keep your startNpriHover/stopNpriHover/getFeatureInfoUrl helpers above or here)
  
  ui.toggleNPRIwms.addEventListener('change', (e) => {
    if (e.target.checked) startNpriHover();
    else stopNpriHover();
  });



  
  /* -------- helpers -------- */
  async function fetchAllArcGISGeoJSON(baseUrl, chunk=2000){
    if (!baseUrl) throw new Error('Missing URL');
    const sep = baseUrl.includes('?') ? '&' : '?';
    let offset = 0, all = [];
    while (true) {
      const url = `${baseUrl}${sep}returnExceededLimitFeatures=true&outSR=4326&resultOffset=${offset}&resultRecordCount=${chunk}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      const gj = await res.json();
      const feats = gj.features || [];
      if (!feats.length) break;
      all = all.concat(feats);
      if (feats.length < chunk) break;
      offset += feats.length;
      if (offset > 1_000_000) break;
    }
    return { type:'FeatureCollection', features: all };
  }
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const centroidOrPoint=f=>!f?.geometry?null:(f.geometry.type==='Point'?f:turf.centroid(f));
  function distanceToFeaturesKm(pt, fc){
    if (!fc.features.length) return 999;
    let min = Infinity;
    for (const f of fc.features) { const pf=centroidOrPoint(f); if(!pf) continue;
      const d = turf.distance(pt, pf, {units:'kilometers'}); if (d<min) min=d; }
    return min;
  }
  function distanceToRoadsKm(pt, fc){
    if (!fc.features.length) return 999;
    let min = Infinity;
    for (const f of fc.features) {
      const g=f.geometry; if(!g) continue;
      if (g.type==='LineString'||g.type==='MultiLineString'){
        const d=turf.pointToLineDistance(pt,f,{units:'kilometers'}); if(d<min) min=d;
      } else {
        const d=turf.distance(pt,centroidOrPoint(f),{units:'kilometers'}); if(d<min) min=d;
      }
    }
    return min;
  }
  function pointInAnyPolygon(pt, polysFC){ for (const f of polysFC.features) if (turf.booleanPointInPolygon(pt,f)) return true; return false; }

  function clearResults() {
    if (hexLayer && window.map.hasLayer(hexLayer)) window.map.removeLayer(hexLayer);
    if (topLayer && window.map.hasLayer(topLayer)) window.map.removeLayer(topLayer);
    hexLayer = null;
    topLayer = null;
    ui.status.innerHTML = '<span class="muted">Cleared results.</span>';
  }
  

  // --- NPRI WMS (hover via GetFeatureInfo) ---
  const NPRI_WMS_URL = '<<YOUR_WMS_URL>>';    // e.g. 'https://.../WMSServer'
  const NPRI_WMS_LAYERS = '<<YOUR_LAYER>>';   // e.g. 'NPRI_Facilities' or '0'

  function startNpriHover() {
    const map = window.map;
    if (!map) return;
    if (!NPRI_WMS_URL || !NPRI_WMS_LAYERS) return; // 👈 guard if not configured
    if (npriLayer) return;
  
  npriLayer = L.tileLayer.wms(NPRI_WMS_URL, {
    layers: NPRI_WMS_LAYERS,
    format: 'image/png',
    transparent: true,
    version: '1.3.0'
  }).addTo(map);

    
  let npriLayer = null;
  let npriMoveHandler = null;
  let npriTip = null;
  
  function getFeatureInfoUrl(layer, latlng) {
    const map = window.map; // use the global you set earlier
    const point = map.latLngToContainerPoint(latlng, map.getZoom());
    const size = map.getSize();
    const base = layer._url;
    const params = {
      request: 'GetFeatureInfo',
      service: 'WMS',
      version: layer.wmsParams.version || '1.3.0',
      styles: layer.wmsParams.styles || '',
      transparent: true,
      format: 'image/png',
      bbox: map.getBounds().toBBoxString(),
      height: size.y,
      width: size.x,
      layers: layer.wmsParams.layers,
      query_layers: layer.wmsParams.layers,
      info_format: 'application/json'
    };
    params[params.version === '1.3.0' ? 'i' : 'x'] = Math.round(point.x);
    params[params.version === '1.3.0' ? 'j' : 'y'] = Math.round(point.y);
    return base + L.Util.getParamString(params, base, true);
  }
  
  function startNpriHover() {
    const map = window.map;
    if (!map) return;
    if (npriLayer) return;
  
    npriLayer = L.tileLayer.wms(NPRI_WMS_URL, {
      layers: NPRI_WMS_LAYERS,
      format: 'image/png',
      transparent: true,
      version: '1.3.0'
    }).addTo(map);
  
    npriTip = L.tooltip({ sticky:true, direction:'top', offset:[0,-6], className:'npri-label' });
  
    let tId = null;
    npriMoveHandler = (e) => {
      if (tId) clearTimeout(tId);
      tId = setTimeout(async () => {
        try {
          const url = getFeatureInfoUrl(npriLayer, e.latlng);
          const res = await fetch(url);
          if (!res.ok) throw new Error('GetFeatureInfo failed');
          const data = await res.json();
  
          const feat = (data.features && data.features[0]) || null;
          const props = feat?.properties || {};
          const name = props.FACILITY_NA || props.FACILITY_NAME || props.NAME || props.Name || 'NPRI Facility';
          const comp = props.COMPANY_NA || props.COMPANY || props.OWNER || '';
          const city = props.CITY || props.MUNICIPALITY || props.MUNICIPAL || '';
          const naics = props.NAICS || props.NAICS_CODE || '';
  
          if (feat) {
            const html = `<b>${name}</b>${comp?`<div>${comp}</div>`:''}${city?`<div>${city}</div>`:''}${naics?`<div>NAICS: ${naics}</div>`:''}`;
            npriTip.setContent(html);
            npriTip.setLatLng(e.latlng);
            if (!npriTip._map) npriTip.addTo(map);
          } else {
            if (npriTip._map) map.removeLayer(npriTip);
          }
        } catch {
          if (npriTip?._map) map.removeLayer(npriTip);
        }
      }, 120);
    };
    
      map.on('mousemove', npriMoveHandler);
    }
    
    function stopNpriHover() {
      const map = window.map;
      if (npriMoveHandler && map) map.off('mousemove', npriMoveHandler);
      npriMoveHandler = null;
      if (npriTip && npriTip._map) map.removeLayer(npriTip);
      npriTip = null;
      if (npriLayer && map) { map.removeLayer(npriLayer); npriLayer = null; }
    }
    
    // hook the checkbox now that `ui` exists
    ui.toggleNPRIwms.addEventListener('change', (e) => {
      if (e.target.checked) startNpriHover();
      else stopNpriHover();
    });

  


  // ---------- 1) CODE MAPPING BY ZONING ----------
  const ZONING_BUCKETS = {
    Industrial: new Set(['IH','IHH','IL','ILT','IM','IMH']),
    Commercial: new Set(['A','C1','C2','C3','C4','C5','C6','C7','CITP','DC1']),
    Institutional: new Set(['MI','MU1','MU2','PS','PU']),
    Residential: new Set([
      'ALD','HR1','HR2','HR4','R1A','R1B','R1C','R1D','R1E','R2A','R2B','R2C',
      'R3','R4','R5','R6','R7','RCH','RCL','RCS','RE','RH','RLD1','RM','RS','RSO','SRR1','UV3'
    ]),
    'Park/Open Space': new Set(['PC','PG','PR','PRM']),
    Agriculture: new Set(['AD','AG','AR','RA']),
  };
  
  // Scores for each bucket
  // ====== CONFIG: 6 buckets → score ======
  const BUCKET_SCORE = {
    'Industrial': 0.90,
    'Commercial': 0.80,
    'Institutional': 0.75,
    'Residential': 0.60,
    'Park/Open Space': 0.40,
    'Agriculture': 0.50
  };
  
  // ====== NORMALIZERS ======
  function norm(s){ return (s==null?'':String(s)).normalize('NFKC').trim(); }
  function upper(s){ return norm(s).toUpperCase(); }
  
  // Normalize zoning like: CITP "Area BC" → CITP ; DC71 "A" → DC71 ; AG (stuff) → AG
  function normalizeZone(z){
    const u = upper(z);
    const m = u.match(/[A-Z0-9]+/); // first token
    return m ? m[0] : u;
  }
  
  // Normalize description like: "CITP - Centre in the Park" → "CITP - CENTRE IN THE PARK"
  function normalizeDesc(d){
    let u = upper(d);
    // collapse weird dashes/whitespace
    u = u.replace(/\s*[-–—]\s*/g, ' - ').replace(/\s+/g, ' ').trim();
    return u;
  }



  // Map a feature's props to our bucket + score using description first, then zoning code
  function landUseScoreAndLabel(props){
    const zRaw = props.lub_zoning ?? props.ZONE ?? props.DISTRICT ?? props.Zoning ?? '';
    const dRaw = props.lub_description ?? props.LAND_USE ?? props.LANDUSE ?? '';
    const zone = normalizeZone(zRaw);
    const desc = normalizeDesc(dRaw);
  
    // 1) description-first classification
    let bucket = classifyByDescription(desc);
  
    // 2) fallback to zoning code if still unknown
    if (!bucket && zone) {
      for (const [b, set] of Object.entries(ZONING_BUCKETS)) {
        if (set.has(zone)) { bucket = b; break; }
      }
    }
  
    // 3) neutral if still unknown
    if (!bucket) return { score: 0.50, label: 'Unclassified', source: { zone: zRaw, desc: dRaw } };
  
    return { score: BUCKET_SCORE[bucket], label: bucket, source: { zone: zRaw, desc: dRaw } };
  }
  
  // Look up land-use at a point: exact polygon hit else nearest polygon
  function landUseAtPointWithDetails(pt, polysFC){
    for (const f of (polysFC.features || [])) {
      try { if (turf.booleanPointInPolygon(pt, f)) return landUseScoreAndLabel(f.properties || {}); }
      catch {}
    }
    if (!(polysFC.features || []).length) return { score: 0.50, label: '(no polygons)' };
    let best=null, bestD=Infinity;
    for (const f of polysFC.features) {
      try {
        const d = turf.distance(pt, turf.centroid(f), { units:'kilometers' });
        if (d < bestD) { bestD = d; best = landUseScoreAndLabel(f.properties || {}); }
      } catch {}
    }
    return best || { score: 0.50, label: 'Unclassified' };
  }



  
  // ====== DESCRIPTION-FIRST CLASSIFIER ======
  function classifyByDescription(descRaw){
    const d = normalizeDesc(descRaw);
  
    // --- exact descriptions (fast path) ---
    // Airport
    if (d === 'A - AIRPORT') return 'Institutional';
  
    // Agriculture family
    if (d.startsWith('AD - AGRICULTURE') || d.startsWith('AG - AGRICULTURE') ||
        d.startsWith('AR - AGRICULTURE') || d.includes('RURAL RESIDENTIAL/AGRICULTURE')) {
      return 'Agriculture';
    }
  
    // Park/Open Space family
    if (d.startsWith('PC -') || d.startsWith('PG -') ||
        d.startsWith('PR -') || d.startsWith('PRM -')) {
      return 'Park/Open Space';
    }
  
    // Industrial family
    if (d.startsWith('IH -') || d.startsWith('IHH -') ||
        d.startsWith('IL -') || d.startsWith('ILT -') ||
        d.startsWith('IM -') || d.startsWith('IMH -')) {
      return 'Industrial';
    }
  
    // Commercial family (C1..C7, CITP - Centre in the Park)
    if (d.startsWith('C1 -') || d.startsWith('C2 -') || d.startsWith('C3 -') ||
        d.startsWith('C4 -') || d.startsWith('C5 -') || d.startsWith('C6 -') ||
        d.startsWith('C7 -') || d.includes('CITP - CENTRE IN THE PARK')) {
      return 'Commercial';
    }
  
    // Institutional family
    if (d.startsWith('MI -') || d.startsWith('MU1 -') || d.startsWith('MU2 -') ||
        d.startsWith('PS -') || d.startsWith('PU -')) {
      return 'Institutional';
    }
  
    // Residential family
    if (/^(ALD|HR1|HR2|HR4|R1A|R1B|R1C|R1D|R1E|R2A|R2B|R2C|R3|R4|R5|R6|R7|RCH|RCL|RCS|RE|RH|RLD1|RM|RS|RSO|SRR1|UV2|UV3|UV4)\b/.test(d)) {
      return 'Residential';
    }
  
    // --- keyword heuristics (if the exact startsWith didn’t trigger) ---
    if (/AGRIC|FARM|RURAL/.test(d)) return 'Agriculture';
    if (/PARK|OPEN SPACE|RECREATION|TRAIL|NATURAL AREA|CONSERV/.test(d)) return 'Park/Open Space';
    if (/INDUSTRIAL|WAREHOUSE|LOGISTICS|PROCESSING|PLANT|BUSINESS PARK/.test(d)) return 'Industrial';
    if (/COMMERCIAL|RETAIL|SHOPPING|OFFICE|SERVICE COMMERCIAL|DOWNTOWN COMMERCIAL/.test(d)) return 'Commercial';
    if (/INSTITUTION|SCHOOL|HOSPITAL|HEALTH|MUNICIPAL|GOVERNMENT|FIRE HALL|POLICE|LIBRARY|CEMETERY/.test(d)) return 'Institutional';
    if (/RESIDENTIAL|APARTMENT|MULTI[- ]FAMILY|SINGLE[- ]DETACHED|TOWN(HOUSE)?|ROW(HOUSE)?|MOBILE HOME|URBAN VILLAGE/.test(d)) return 'Residential';
  
    // --- Direct Control nuance: try to infer from trailing words ---
    if (d.includes('DC - DIRECT CONTROL')) {
      if (/RESIDENTIAL|URBAN VILLAGE/.test(d)) return 'Residential';
      if (/COMMERCIAL|RETAIL|OFFICE/.test(d)) return 'Commercial';
      if (/INDUSTRIAL/.test(d)) return 'Industrial';
      if (/PARK|OPEN SPACE|RECREATION/.test(d)) return 'Park/Open Space';
      if (/AGRIC/.test(d)) return 'Agriculture';
      if (/INSTITUTION|SCHOOL|HOSPITAL|GOVERNMENT/.test(d)) return 'Institutional';
      return null; // unknown DC → let code try; else neutral
    }
  
    return null; // let code fallback try
  }
  
 

  /* -------- state -------- */
  let LAYERS = {};
  let appReady = false;
  let hexLayer=null, topLayer=null;
  let paLayer=null, stnLayer=null;
  let npriFacilitiesWMS = null;
  const colorForAQHI = a => (isNaN(+a)?'#666':(+a<=3?'#2ca25f':+a<=6?'#ffb000':+a<=10?'#d73027':'#7a1fa2'));

  async function buildStationsLayer() {
    try {
      await window.dataReady;
      const rows = await window.fetchAllStationData();
      if (!rows?.length) return L.layerGroup();
      return L.layerGroup(rows.map(r => L.circleMarker([+r.lat,+r.lon],{
        radius:5, weight:2, color:'#333', fillColor:colorForAQHI(r.aqhi), fillOpacity:1
      }).bindPopup(r.html).bindTooltip(`${r.stationName} — AQHI: ${r.aqhi}`,{direction:'top',offset:[0,-8]})));
    } catch (e) { console.error(e); return L.layerGroup(); }
  }

  async function buildExternalPointsLayer(url, style={}){
    try {
      const res=await fetch(url); if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const json=await res.json();
      const fc = json?.type==='FeatureCollection'?json:
                 Array.isArray(json)?arrayToFeatureCollection(json):
                 json?.data?arrayToFeatureCollection(json.data):
                 json?.features?{type:'FeatureCollection',features:json.features}:
                 arrayToFeatureCollection(Object.values(json));
      return L.geoJSON(fc, {
        pointToLayer:(f,ll)=>L.circleMarker(ll,{radius:4,weight:1.5,color:style.color||'#333',fillColor:'#fff',fillOpacity:1})
          .bindTooltip(f.properties?.name||f.properties?.label||style.label||'',{direction:'top',offset:[0,-6]})
      });
    } catch(e){ console.error('External layer failed',e); return null; }
  }
  function arrayToFeatureCollection(arr){
    const latK=['lat','latitude','Latitude','LAT','Lat'].find(k=>k in (arr[0]||{}));
    const lonK=['lon','lng','long','longitude','Longitude','LON','Lng'].find(k=>k in (arr[0]||{}));
    return { type:'FeatureCollection', features: (arr||[]).map(r=>({
      type:'Feature', properties:{...r}, geometry:{type:'Point',coordinates:[+r[lonK],+r[latK]]}
    })).filter(f=>isFinite(f.geometry.coordinates[0])&&isFinite(f.geometry.coordinates[1])) };
  }

  async function queryAllLandUse() {
    const url = 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Land_Use_Bylaw/FeatureServer/0';
    return await new Promise((resolve, reject) => {
      L.esri.query({ url })
        .where('1=1')
        .fields(['*'])
        .returnGeometry(true)
        .run((err, fc) => err ? reject(err) : resolve(fc));
    });
  }

    // for MCDA use across functions
  let CENSUS_FC = null;
  let CENSUS_MIN = 0, CENSUS_MAX = 1;
  
  /* -------- init: fetch data for MCDA + build overlays -------- */
  async function init(){
    try {
      ui.status.textContent='Loading live layers…';
      const [wifi,play,parks,fields,splash,bldg,roads,pemu,land] = await Promise.all([
        fetchAllArcGISGeoJSON(URLS.wifi),
        fetchAllArcGISGeoJSON(URLS.play),
        fetchAllArcGISGeoJSON(URLS.parks),
        fetchAllArcGISGeoJSON(URLS.fields),
        fetchAllArcGISGeoJSON(URLS.splash),
        fetchAllArcGISGeoJSON(URLS.bldg),
        fetchAllArcGISGeoJSON(URLS.roads),
        fetchAllArcGISGeoJSON(URLS.pemu),
        queryAllLandUse()
      ]);

      const amenities = {
        type:'FeatureCollection',
        features:[]
          .concat(play.features)
          .concat(parks.features.map(f=>turf.centroid(f)))
          .concat(fields.features.map(f=>turf.centroid(f)))
          .concat(splash.features)
      };
      const bldgCentroids = { type:'FeatureCollection', features:bldg.features.map(f=>turf.centroid(f)) };

      LAYERS = { wifi, play, parks, fields, splash, amenities, bldgPolys:bldg, bldgCentroids, roads, pemu, land };

      try { const bb=turf.bbox(land); map.fitBounds([[bb[1],bb[0]],[bb[3],bb[2]]],{padding:[15,15]}); } catch {}

      // Display overlays (constant widths)
      const wifiDisp  = L.geoJSON(wifi,  { pointToLayer:(f,ll)=>L.circleMarker(ll,{radius:5,weight:1,color:'#016797',fillOpacity:0.8}) });
      const playDisp  = L.geoJSON(play,  { pointToLayer:(f,ll)=>L.circleMarker(ll,{radius:4,weight:1,color:'#0099cb',fillOpacity:0.9}) });
      const parksDisp = L.geoJSON(parks, { style:()=>({color:'#2e7d32',weight:1,fillColor:'#a5d6a7',fillOpacity:0.25}) });
      const fieldsDisp= L.geoJSON(fields,{ style:()=>({color:'#1b5e20',weight:1,fillColor:'#c8e6c9',fillOpacity:0.25}) });
      const splashDisp= L.geoJSON(splash,{ pointToLayer:(f,ll)=>L.circleMarker(ll,{radius:4,weight:1,color:'#0aa2ff',fillOpacity:0.9}) });
      const pemuDisp = L.geoJSON(pemu, {
        style: () => ({
          color: '#6a0080',
          weight: 1.2,
          fillColor: '#dcb6ef',
          fillOpacity: 0.25
        }),
        onEachFeature: (f, lyr) => {
          const p = f.properties || {};
          // Try a few likely field names; fall back to a generic label
          const name = p.NAME || p.Name || p.PEMU_NAME || 'Priority Env. Mgmt Unit';
          const cat  = p.CATEGORY || p.Category || p.TYPE || p.Type || '';
          const tip  = `${name}${cat ? ' — ' + cat : ''}${excludePEMU.checked ? ' (excluded)' : ''}`;
      
          // Hover tooltip (no click needed)
          lyr.bindTooltip(tip, {
            sticky: true,
            direction: 'top',
            offset: [0, -6],
            className: 'npri-label'
          });
      
          // Optional: keep a click popup with more details
          lyr.bindPopup(`
            <div style="min-width:220px">
              <b>${name}</b><br/>
              ${cat ? `<div>Type: ${cat}</div>` : ''}
              <div>${excludePEMU.checked ? '<span class="err">Currently excluded in scoring</span>' : 'Visible only (not excluded)'}</div>
            </div>
          `);
      
          // Highlight on hover
          lyr.on('mouseover', () => {
            lyr.setStyle({ weight: 2, color: '#4a0060', fillOpacity: 0.35 });
            lyr.bringToFront?.();
          });
          lyr.on('mouseout', () => pemuDisp.resetStyle(lyr));
        }
      });
      const landDisp = L.geoJSON(land, {
        style: f => {
          const det = landUseScoreAndLabel(f.properties || {});
          const t = (det.score - 0.4) / (0.9 - 0.4);
          return { color:'#666', weight:0.5, fillColor:`hsl(${210-160*Math.max(0,Math.min(1,t))},60%,70%)`, fillOpacity:0.35 };
        },
        onEachFeature: (f, lyr) => {
          const p = f.properties || {};
          const det = landUseScoreAndLabel(p);
          const zone = p.lub_zoning ?? '';
          const desc = p.lub_description ?? '';
      
          // HOVER (no click)
          const tip = (desc || zone || 'Land-use') + ` — ${det.label} (${det.score.toFixed(2)})`;
          lyr.bindTooltip(tip, { permanent:false, sticky:true, direction:'top', offset:[0,-6], className:'npri-label' });
      
          // Optional: keep click popup
          lyr.bindPopup(`
            <div style="min-width:240px">
              <strong>Land-use</strong>
              <table style="width:100%;font-size:12px">
                ${zone ? `<tr><td>Zone</td><td>${zone}</td></tr>` : ''}
                ${desc ? `<tr><td>Description</td><td>${desc}</td></tr>` : ''}
                <tr><td>Mapped class</td><td>${det.label}</td></tr>
                <tr><td>Score</td><td><b>${det.score.toFixed(2)}</b></td></tr>
              </table>
            </div>
          `);
      
          lyr.on('mouseover', () => { lyr.setStyle({ weight:1.2, color:'#333', fillOpacity:0.45 }); lyr.bringToFront?.(); });
          lyr.on('mouseout',  () => landDisp.resetStyle(lyr));
        }
      });





      // Pull EAs once for MCDA, with geometry (paginate to be safe)
      async function queryAllCensus(returnGeom = true) {
        const base = 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/2018_Municipal_Census___Enumeration_Areas_Map/FeatureServer/0/query';
        const fields = ['tot_pop','TOT_POP','Shape_Area','shape_area','EA_ID'].join(',');
        const chunk = 2000;
        let offset = 0;
        const out = { type:'FeatureCollection', features:[] };
        while (true) {
          const url = `${base}?where=1=1&outFields=${encodeURIComponent(fields)}&f=geojson` +
                      `&returnExceededLimitFeatures=true&outSR=4326` +
                      `&resultOffset=${offset}&resultRecordCount=${chunk}` +
                      `&returnGeometry=${returnGeom ? 'true' : 'false'}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`Census HTTP ${res.status} at offset ${offset}`);
          const gj = await res.json();
          const feats = gj.features || [];
          out.features.push(...feats);
          if (feats.length < chunk) break;
          offset += feats.length;
        }
        return out;
      }

      
      try {
        const fc = await queryAllCensus(true);
        // compute density per feature & keep a tight FC for point lookups
        const feats = (fc.features||[]).filter(f=>f && f.geometry && f.properties);
        const densVals = [];
        feats.forEach(f=>{
          const p=f.properties;
          const tot = Number(p.tot_pop ?? p.TOT_POP ?? 0);
          const km2 = (function(){
            const m2Attr = Number(p.Shape_Area ?? p.shape_area ?? p.SHAPE__Area ?? p.SHAPE_Area);
            if (Number.isFinite(m2Attr) && m2Attr>0) return m2Attr/1e6;
            try { const m2=turf.area(f); return m2>0?m2/1e6:0; } catch { return 0; }
          })();
          const d = km2>0 ? (tot/km2) : 0;
          p._density = d;
          if (Number.isFinite(d)) densVals.push(d);
        });
        if (densVals.length) {
          CENSUS_MIN = Math.min(...densVals);
          CENSUS_MAX = Math.max(...densVals);
        }
        CENSUS_FC = { type:'FeatureCollection', features: feats };
      } catch(e) {
        console.warn('Census FC for MCDA failed; pop-density weight will act as neutral.', e);
      }


      
      // Streaming Esri overlays (constant style)
      const roadsFL = L.esri.featureLayer({
        url:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Street_Network1/FeatureServer/0',
        pane:'features', style:{color:'#a16d00',weight:1,opacity:0.9}, simplifyFactor:0.1, precision:7
      });
      const bldgFL  = L.esri.featureLayer({
        url:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Building_Footprints/FeatureServer/0',
        pane:'features', style:{color:'#444',weight:0.7,fillColor:'#bdbdbd',fillOpacity:0.35}, simplifyFactor:0.1, precision:7
      });

      // checkbox ↔ layer wiring
      function bindToggle(el, layer){ if(!el) return;
        if (el.checked) { layer.addTo(map); layer.bringToFront?.(); }
        el.addEventListener('change', e => e.target.checked ? layer.addTo(map).bringToFront?.() : map.removeLayer(layer));
      }
      bindToggle(ui.toggleWifi,   wifiDisp);
      bindToggle(ui.togglePlay,   playDisp);
      bindToggle(ui.toggleParks,  parksDisp);
      bindToggle(ui.toggleFields, fieldsDisp);
      bindToggle(ui.toggleSplash, splashDisp);
      bindToggle(ui.togglePEMU,   pemuDisp);
      bindToggle(ui.toggleLand,   landDisp);
      bindToggle(ui.toggleRoads,  roadsFL);
      bindToggle(ui.toggleBldg,   bldgFL);

      ui.status.textContent = 'Ready. Click Recompute.';
      appReady = true;
      
    } catch(e){
      console.error(e);
      ui.status.innerHTML = `<span class="err">Failed to load data: ${e.message}</span>`;
    }
    
  }

  function popDensityAtPoint(pt, censusFC){
    if (!censusFC || !censusFC.features?.length) return null;
    for (const f of censusFC.features) {
      try { if (turf.booleanPointInPolygon(pt, f)) return Number(f.properties?._density) || 0; }
      catch {}
    }
    return null; // if not found, treat as neutral later
  }
  
  /* --------------------------- SCORING ------------------------------ */
  function recompute(){
    if (!appReady) { ui.status.innerHTML = '<span class="warn">Still loading…</span>'; return; }
    if (!LAYERS.land) { ui.status.innerHTML='<span class="warn">Data not loaded yet…</span>'; return; }
    ui.status.innerHTML='<span class="muted">Computing…</span>';

    const cellKm = +ui.cellkm.value, dMax = +ui.dmax.value;
    const mode = ui.mode.value, roadsPref = ui.roadsPref.value, excludePEMU = ui.excludePEMU.checked;

    let w = {
      wifi:+ui.w_wifi.value, amen:+ui.w_amen.value, road:+ui.w_road.value,
      lu:+ui.w_lu.value, bld:+ui.w_bld.value, pop:+ui.w_pop.value
    };
    const s = Object.values(w).reduce((a,b)=>a+b,0)||1;
    Object.keys(w).forEach(k=>w[k]=w[k]/s);


    const { wifi, amenities, bldgCentroids, roads, pemu, land } = LAYERS;
    const bbox = turf.bbox(land);
    const hex = turf.hexGrid(bbox, cellKm, { units:'kilometers' });

    const raw = []; let maxBldDen=0;
    for (const cell of hex.features){
      const center = turf.centerOfMass(cell);
      const dWifi = distanceToFeaturesKm(center, wifi);
      const dAmen = distanceToFeaturesKm(center, amenities);
      const dRoad = distanceToRoadsKm(center, roads);
      const ring = turf.circle(center, 0.1, {steps:16, units:'kilometers'});
      const dens = turf.pointsWithinPolygon(bldgCentroids, ring).features.length; if (dens>maxBldDen) maxBldDen=dens;
      const luDet = landUseAtPointWithDetails(center, land);
      const pd = popDensityAtPoint(center, CENSUS_FC); // may be null if outside or census missing
      const allowed = excludePEMU && pointInAnyPolygon(center, pemu) ? 0 : 1;
      raw.push({ cell, center, dWifi, dAmen, dRoad, dens, luScore:luDet.score, luLabel:luDet.label, pd, allowed });
    }

    const denMax = Math.max(1, maxBldDen);
    for (const r of raw) {
      const s_wifi = clamp(1 - (r.dWifi / dMax), 0, 1);
      const s_amen = (mode === 'exposure') ? clamp(1 - (r.dAmen / dMax), 0, 1)
                                           : clamp((r.dAmen / dMax), 0, 1);
      const s_road = (roadsPref === 'closer') ? clamp(1 - (r.dRoad / dMax), 0, 1)
                                              : clamp((r.dRoad / dMax), 0, 1);
      const s_bld  = clamp(r.dens / denMax, 0, 1);
      const s_lu   = clamp(r.luScore, 0, 1);
    
      let s_pop;
      if (r.pd == null || !isFinite(r.pd) || CENSUS_MAX <= CENSUS_MIN) {
        s_pop = 0.5;
      } else {
        const t = (r.pd - CENSUS_MIN) / (CENSUS_MAX - CENSUS_MIN);
        s_pop = (mode === 'exposure') ? t : (1 - t);
      }
    
      r.components = { s_wifi, s_amen, s_road, s_bld, s_lu, s_pop };
      r.inputs = {
        dWifi_km: r.dWifi,
        dAmen_km: r.dAmen,
        dRoad_km: r.dRoad,
        bldgCount100m: r.dens,
        landUseLabel: r.luLabel,
        landUseScore: r.luScore,
        popDensity: (r.pd ?? null)
      };
    
      r.scoreRaw = w.wifi*s_wifi + w.amen*s_amen + w.road*s_road +
                   w.lu*s_lu + w.bld*s_bld + w.pop*s_pop;
      r.score = r.scoreRaw * r.allowed;
    }


    
    const minS = Math.min(...raw.map(r=>r.score)), maxS = Math.max(...raw.map(r=>r.score));
    const colorFor=s=>{ const t=(s-minS)/(maxS-minS+1e-9); return `hsl(${200-160*t}, ${30+40*t}%, ${85-45*t}%)`; };

    hex.features.forEach((f,i)=>{ const r=raw[i]; f.properties={ score:+r.score.toFixed(3), lu_score:+r.luScore.toFixed(2), lu_label:r.luLabel }; });

    if (hexLayer) map.removeLayer(hexLayer);
    hexLayer = L.geoJSON(hex, {
      pane:'suitability',
      style:f=>({color:'#aaa',weight:0.4,fillColor:colorFor(f.properties.score),fillOpacity:0.78})
    }).addTo(map);
    if (ui.toggleHex && !ui.toggleHex.checked) map.removeLayer(hexLayer);

    const top10 = raw.filter(r=>r.allowed===1).sort((a,b)=>b.score-a.score).slice(0,10);
    const topFC = { type:'FeatureCollection', features: top10.map(r=>({type:'Feature',properties:{score:+r.score.toFixed(3)},geometry:r.center.geometry})) };
    // Save a snapshot for export
    window.lastMCDA = {
      when: new Date().toISOString(),
      params: {
        mode,
        roadsPref,
        excludePEMU,
        cellKm,
        dMax,
        weightsNormalized: { ...w }
      },
      top10,   // each entry has .center, .score, .components, .inputs
      bbox     // from turf.bbox(land)
    };

    
    if (topLayer) map.removeLayer(topLayer);
    topLayer = L.geoJSON(topFC, {
      pane:'markers',
      pointToLayer:(f,ll)=>L.circleMarker(ll,{radius:6,weight:2,color:'#fe0002',fillColor:'#fff',fillOpacity:1})
        .bindPopup(`<b>Candidate</b><br>Score: ${f.properties.score}`)
    }).addTo(map);
    if (ui.toggleTop && !ui.toggleTop.checked) map.removeLayer(topLayer);
    topLayer.bringToFront();

    ui.status.innerHTML = `<span class="ok">Done. Cells: ${hex.features.length}, Top10 shown.</span>`;
    ui.lu_readout.textContent = '—';
  }

 
  
    /* -------- wire up + go -------- */
    ui.runBtn.addEventListener('click', recompute);
    ui.btnClear.addEventListener('click', clearResults);
  
  function exportTop10CSV() {
    const snap = window.lastMCDA;
    if (!snap || !snap.top10?.length) {
      alert('No Top 10 available yet. Click “Recompute” first.');
      return;
    }
  
    const metaLines = [
      '# Rapid Suitability (MCDA-lite) — Top 10 Export',
      `# generated_at, ${snap.when}`,
      `# mode, ${snap.params.mode}`,
      `# roadsPref, ${snap.params.roadsPref}`,
      `# excludePEMU, ${snap.params.excludePEMU}`,
      `# cellKm, ${snap.params.cellKm}`,
      `# dMax_km, ${snap.params.dMax}`,
      `# weights_normalized, wifi=${snap.params.weightsNormalized.wifi}; amen=${snap.params.weightsNormalized.amen}; road=${snap.params.weightsNormalized.road}; lu=${snap.params.weightsNormalized.lu}; bld=${snap.params.weightsNormalized.bld}; pop=${snap.params.weightsNormalized.pop}`,
      ''
    ].join('\n');
  
    // Columns you’ll get per candidate row:
    const header = [
      'rank',
      'lat','lon',
      'score',
      // component scores (0–1):
      's_wifi','s_amen','s_road','s_lu','s_bld','s_pop',
      // raw inputs that fed the scoring:
      'dWifi_km','dAmen_km','dRoad_km','bldgCount100m',
      'landUseLabel','landUseScore',
      'popDensity_people_per_km2'
    ];
  
    let csv = header.join(',') + '\n';
  
    snap.top10.forEach((r, i) => {
      const coords = r.center?.geometry?.coordinates || [null, null];
      const lat = coords[1], lon = coords[0];
  
      const row = [
        i + 1,
        lat, lon,
        (r.score ?? ''),
        // component scores:
        (r.components?.s_wifi ?? ''),
        (r.components?.s_amen ?? ''),
        (r.components?.s_road ?? ''),
        (r.components?.s_lu   ?? ''),
        (r.components?.s_bld  ?? ''),
        (r.components?.s_pop  ?? ''),
        // raw inputs:
        (r.inputs?.dWifi_km ?? ''),
        (r.inputs?.dAmen_km ?? ''),
        (r.inputs?.dRoad_km ?? ''),
        (r.inputs?.bldgCount100m ?? ''),
        JSON.stringify(r.inputs?.landUseLabel ?? ''),
        (r.inputs?.landUseScore ?? ''),
        (r.inputs?.popDensity ?? '')
      ];
  
      csv += row.join(',') + '\n';
    });
  
    const blob = new Blob([metaLines + csv], { type: 'text/csv;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'strathcona_top10_mcda.csv';
    a.click();
    URL.revokeObjectURL(a.href);
  }
  
  // Wire up the button
  document.getElementById('btnExportMCDA')?.addEventListener('click', exportTop10CSV);

  
  // PurpleAir toggle
  ui.togglePA.addEventListener('change', async (e) => {
    if (e.target.checked) {
      if (!paLayer) paLayer = await buildExternalPointsLayer(LAYER_URLS.purpleair, { color: '#7a1fa2', label: 'PurpleAir' });
      if (paLayer) { paLayer.addTo(map); paLayer.bringToFront?.(); }
    } else {
      if (paLayer) map.removeLayer(paLayer);
    }
  });
  
  // Stations toggle (data.js)
  ui.toggleStations.addEventListener('change', async (e) => {
    if (e.target.checked) {
      if (!stnLayer) stnLayer = await buildStationsLayer();
      if (stnLayer) { stnLayer.addTo(map); stnLayer.bringToFront?.(); }
    } else {
      if (stnLayer) map.removeLayer(stnLayer);
    }
  });
  
  init(); // load data, build display overlays, set Ready

});
</script>

</body>
</html>
