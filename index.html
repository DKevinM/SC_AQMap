<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Rapid Suitability (MCDA-lite) — Strathcona County</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.12/dist/esri-leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    :root { --panel-w: 320px; --fs: 11px; }
    html, body { height:100%; margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto; font-size:var(--fs); }
    #app { display:grid; grid-template-columns:1fr var(--panel-w); grid-template-rows:100vh; width:100vw; overflow:hidden; }
    #map { min-width:0; height:100%; }
    #panel {
      height:100%; overflow:auto; padding:8px 10px; border-left:1px solid #ddd; background:#fff; line-height:1.32; z-index:10000;
      display:flex; flex-direction:column;
    }
    h2 { font-size:12px; margin:2px 0 8px; }
    .small { color:#555; font-size:10px; }
    .group { margin:8px 0; }
    label { display:block; margin-bottom:4px; font-weight:600; }
    .row { display:flex; gap:6px; align-items:center; }
    input[type="range"] { width:100%; }
    select, input[type="checkbox"] { font-size:var(--fs); }
    .btn { display:inline-block; padding:5px 5px; background:#016797; color:#fff; border-radius:7px; cursor:pointer; text-decoration:none; }
    .badge { font-size:11px; background:#f0f0f0; padding:1px 5px; border-radius:999px; }
    .muted { color:#777; } .ok { color:#0a7; } .warn { color:#d70; } .err { color:#d33; }
    .hr { height:1px; background:#eee; margin:8px 0; }
    .legend { display:flex; height:10px; margin:4px 0 6px; background:linear-gradient(90deg,#fff7bf,#79bcd7,#0b3c73); border:1px solid #ccc; }
    .footer { margin-top:auto; padding-top:8px; border-top:1px dashed #e5e5e5; }
    /* tighter layers list */
    .layers-list label { display:block; margin:0; line-height:1.2; }
    .layers-list label + label { margin-top:2px; }
  </style>
</head>
<body>
<div id="app">
  <div id="map"></div>

  <aside id="panel">
    <h2>Rapid Suitability (MCDA-lite)</h2>
    <div class="small">Hex-grid scoring from live ArcGIS GeoJSON. Adjust and click <b>Recompute</b>.</div>

    <div class="group">
      <label>Objective</label>
      <select id="mode">
        <option value="exposure">Population/Exposure (closer to amenities)</option>
        <option value="background">Background/Regional (farther from amenities)</option>
      </select>
    </div>

    <div class="group">
      <label>Roads preference</label>
      <select id="roadsPref">
        <option value="closer">Closer is better (near traffic)</option>
        <option value="farther">Farther is better (background)</option>
      </select>
    </div>

    <div class="group">
      <label>Hex cell size (km)</label>
      <div class="row">
        <input type="range" id="cellkm" min="0.3" max="2.5" step="0.1" value="0.6">
        <span id="cellkm_val" class="badge">0.6</span>
      </div>
    </div>

    <div class="group">
      <label>Distance cap for proximity (km) <span class="small">(linear rescale)</span></label>
      <div class="row">
        <input type="range" id="dmax" min="0.5" max="6" step="0.5" value="3">
        <span id="dmax_val" class="badge">3</span>
      </div>
    </div>

    <div class="group">
      <label>Weights (auto-normalize)</label>
      <div class="row"><span class="small" style="width:110px">Wi-Fi proximity</span><input type="range" id="w_wifi" min="0" max="1" step="0.05" value="0.25"><span id="w_wifi_val" class="badge">0.25</span></div>
      <div class="row"><span class="small" style="width:110px">Amenities proximity</span><input type="range" id="w_amen" min="0" max="1" step="0.05" value="0.25"><span id="w_amen_val" class="badge">0.25</span></div>
      <div class="row"><span class="small" style="width:110px">Roads proximity</span><input type="range" id="w_road" min="0" max="1" step="0.05" value="0.20"><span id="w_road_val" class="badge">0.20</span></div>
      <div class="row"><span class="small" style="width:110px">Land-use score</span><input type="range" id="w_lu" min="0" max="1" step="0.05" value="0.20"><span id="w_lu_val" class="badge">0.20</span></div>
      <div class="row"><span class="small" style="width:110px">Bldg density</span><input type="range" id="w_bld" min="0" max="1" step="0.05" value="0.10"><span id="w_bld_val" class="badge">0.10</span></div>
      <div class="small muted">Sum is normalized to 1.</div>
    </div>

    <div class="group">
      <label><input type="checkbox" id="excludePEMU"> Exclude inside Priority Environmental Mgmt Units</label>
    </div>

    <!-- LAYERS: click on/off -->
    <div class="group">
      <label>Layers (click to show/hide)</label>
      <div class="layers-list small">
        <label><input type="checkbox" id="toggleHex" checked> Suitability hexes</label>
        <label><input type="checkbox" id="toggleTop" checked> Top 10 candidates</label>
        <label><input type="checkbox" id="toggleWifi"> Buildings with Wi-Fi</label>
        <label><input type="checkbox" id="togglePlay"> Playgrounds</label>
        <label><input type="checkbox" id="toggleParks"> Parks</label>
        <label><input type="checkbox" id="toggleFields"> Playing Fields</label>
        <label><input type="checkbox" id="toggleSplash"> Splash Parks</label>
        <label><input type="checkbox" id="toggleRoads"> Roads</label>
        <label><input type="checkbox" id="toggleBldg"> Building footprints</label>
        <label><input type="checkbox" id="togglePEMU"> Priority Env. Mgmt Units</label>
        <label><input type="checkbox" id="toggleLand"> Land-use polygons</label>
        <label><input type="checkbox" id="togglePA"> PurpleAir sensors</label>
        <label><input type="checkbox" id="toggleStations"> AQ stations</label>
      </div>
    </div>
    
    <!-- Land-use score legend/explanation -->
    <div class="group small">
      <b>Land-use score mapping</b>
      <table style="font-size:11px;border-collapse:collapse;margin-top:4px">
        <tr><td>Industrial (IND)</td><td style="padding-left:8px">0.90</td></tr>
        <tr><td>Commercial (COM)</td><td style="padding-left:8px">0.80</td></tr>
        <tr><td>Institutional (INS)</td><td style="padding-left:8px">0.75</td></tr>
        <tr><td>Residential (RES)</td><td style="padding-left:8px">0.60</td></tr>
        <tr><td>Park / Open Space</td><td style="padding-left:8px">0.40</td></tr>
        <tr><td>Agriculture</td><td style="padding-left:8px">0.50</td></tr>
        <tr><td>Default/Other</td><td style="padding-left:8px">0.50</td></tr>
      </table>
    </div>

    <div class="group">
      <a id="runBtn" class="btn">Recompute</a>
      <span id="status" class="small muted">Loading data…</span>
    </div>

    <div class="group">
      <div class="small"><b>Legend</b> (low → high)</div>
      <div class="legend"></div>
    </div>

    <div class="hr"></div>
    <div class="small">
      Notes: Uses Wi-Fi bldgs, amenities (Playgrounds, Parks, Playing Fields, Splash Parks), Roads, Land-Use, and Building Footprints. Contours are ignored (no slope inference here).
    </div>

    <div class="footer small">
      <b>Land-use score here:</b> <span id="lu_readout">—</span>
    </div>
  </aside>
</div>

<!-- stations data helpers -->
<script src="data.js"></script>

<script>
/* ------------------------- CONFIG / LAYERS ------------------------- */
const URLS = {
  wifi:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/County_Buildings_with_WiFi/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  play:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Playgrounds/FeatureServer/3/query?outFields=*&where=1%3D1&f=geojson',
  parks: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Parks/FeatureServer/2/query?outFields=*&where=1%3D1&f=geojson',
  fields:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Playing_Fields/FeatureServer/5/query?outFields=*&where=1%3D1&f=geojson',
  splash:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Splash_Parks/FeatureServer/8/query?outFields=*&where=1%3D1&f=geojson',
//  bldg:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Building_Footprints/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
//  roads: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Street_Network1/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  pemu:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Priority_Environment_Management_Units/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  land:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Land_Use_Bylaw/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson'
};

  // Roads — fixed width, no zoom listener, minimal simplification
const roadsLayer = L.esri.featureLayer({
  url: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Street_Network1/FeatureServer/0',
  pane: 'features',
  where: '1=1',
  fields: ['*'],
  style: { color: '#a33', weight: 1.2, opacity: 0.9 },  // <-- constant width
  simplifyFactor: 0.1,  // was 0.6; too high makes lines look jagged/missing
  precision: 7          // was 5; bumping preserves geometry detail
}).addTo(map);

// Building footprints — fixed outline/fill, no zoom-based changes
const footprintsLayer = L.esri.featureLayer({
  url: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Building_Footprints/FeatureServer/0',
  pane: 'features',
  where: '1=1',
  fields: ['*'],
  style: { color: '#444', weight: 0.7, fillColor: '#bdbdbd', fillOpacity: 0.35 },
  simplifyFactor: 0.1,
  precision: 7
}).addTo(map);


// External points (only PurpleAir here)
const LAYER_URLS = {
  purpleair: 'https://raw.githubusercontent.com/DKevinM/AB_datapull/main/data/ACA_PM25_map.json'
};

// land-use mapping (label + score)
function landUseScoreAndLabel(props) {
  const raw = (props.ZONE || props.DISTRICT || props.LAND_USE || props.LANDUSE || props.Zoning || '').toString();
  const lut = [
    {match:/industrial|^ind$/i,   score:0.90, label:'Industrial'},
    {match:/commercial|^com$/i,   score:0.80, label:'Commercial'},
    {match:/institution/i,        score:0.75, label:'Institutional'},
    {match:/residential|^res$/i,  score:0.60, label:'Residential'},
    {match:/park|open ?space/i,   score:0.40, label:'Park/Open Space'},
    {match:/agric/i,              score:0.50, label:'Agriculture'}
  ];
  for (const r of lut) if (r.match.test(raw)) return {score:r.score, label:r.label};
  return {score:0.50, label: raw || 'Default'};
}
function landUseAtPointWithDetails(pt, polysFC){
  for (const f of polysFC.features) {
    if (turf.booleanPointInPolygon(pt, f)) return landUseScoreAndLabel(f.properties||{});
  }
  if (!polysFC.features.length) return {score:0.5, label:'(no polygons)'};
  let best = {score:0.5, label:'Nearest poly'}, min = Infinity;
  for (const f of polysFC.features) {
    const d = turf.distance(pt, turf.centroid(f), {units:'kilometers'});
    if (d < min) { min = d; best = landUseScoreAndLabel(f.properties||{}); }
  }
  return best;
}

/* --------------------------- UI / MAP ------------------------------ */
const map = L.map('map').setView([53.53, -113.30], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20}).addTo(map);
// Panes (Z-order): tiles (200) < features (400) < suitability (410) < markers (420)
map.createPane('features');    map.getPane('features').style.zIndex = 400;
map.createPane('suitability'); map.getPane('suitability').style.zIndex = 410;
map.createPane('markers');     map.getPane('markers').style.zIndex = 420;

setTimeout(() => map.invalidateSize(), 0);
window.addEventListener('resize', () => map.invalidateSize());

const ui = {
  mode: document.getElementById('mode'),
  roadsPref: document.getElementById('roadsPref'),
  cellkm: document.getElementById('cellkm'),
  cellkm_val: document.getElementById('cellkm_val'),
  dmax: document.getElementById('dmax'),
  dmax_val: document.getElementById('dmax_val'),
  w_wifi: document.getElementById('w_wifi'),
  w_wifi_val: document.getElementById('w_wifi_val'),
  w_amen: document.getElementById('w_amen'),
  w_amen_val: document.getElementById('w_amen_val'),
  w_road: document.getElementById('w_road'),
  w_road_val: document.getElementById('w_road_val'),
  w_lu: document.getElementById('w_lu'),
  w_lu_val: document.getElementById('w_lu_val'),
  w_bld: document.getElementById('w_bld'),
  w_bld_val: document.getElementById('w_bld_val'),
  excludePEMU: document.getElementById('excludePEMU'),
  togglePA: document.getElementById('togglePA'),
  toggleStations: document.getElementById('toggleStations'),
  runBtn: document.getElementById('runBtn'),
  status: document.getElementById('status'),
  lu_readout: document.getElementById('lu_readout'),
  toggleHex: document.getElementById('toggleHex'),
  toggleTop: document.getElementById('toggleTop'),
};
function hookRange(inp, lab){ const f=()=>lab.textContent=(+inp.value).toFixed(inp.step.includes('.')?1:0); inp.addEventListener('input',f); f(); }
[['cellkm','cellkm_val'],['dmax','dmax_val'],['w_wifi','w_wifi_val'],['w_amen','w_amen_val'],['w_road','w_road_val'],['w_lu','w_lu_val'],['w_bld','w_bld_val']].forEach(([a,b])=>hookRange(ui[a],ui[b]));

/* --------------------------- DATA LOAD ---------------------------- */
async function fetchAllArcGISGeoJSON(baseUrl, chunk=2000){
  const sep = baseUrl.includes('?') ? '&' : '?';
  let offset = 0, all = [];
  while (true) {
    const url = `${baseUrl}${sep}returnExceededLimitFeatures=true&orderByFields=OBJECTID&outSR=4326&resultOffset=${offset}&resultRecordCount=${chunk}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const gj = await res.json();
    const feats = gj.features || [];
    if (feats.length === 0) break;
    all = all.concat(feats);
    if (feats.length < chunk) break;
    offset += feats.length;
    // safety: avoid runaway loops
    if (offset > 1_000_000) break;
  }
  return { type:'FeatureCollection', features: all };
}

let LAYERS = {};
let hexLayer, topLayer;
let paLayer = null, stnLayer = null;

function colorForAQHI(a){
  const v = Number(a);
  if (isNaN(v)) return '#666';
  if (v <= 3)  return '#2ca25f';
  if (v <= 6)  return '#ffb000';
  if (v <= 10) return '#d73027';
  return '#7a1fa2';
}

async function buildStationsLayer() {
  try {
    await window.dataReady;
    const rows = await window.fetchAllStationData();
    if (!rows || !rows.length) { console.warn('No station rows'); return L.layerGroup(); }
    const markers = rows.map(r => L.circleMarker([+r.lat,+r.lon],{
      radius:5, weight:2, color:'#333', fillColor:colorForAQHI(r.aqhi), fillOpacity:1
    }).bindPopup(r.html).bindTooltip(`${r.stationName} — AQHI: ${r.aqhi}`,{direction:'top',offset:[0,-8]}));
    return L.layerGroup(markers);
  } catch (err) {
    console.error('Stations build failed:', err);
    return L.layerGroup();
  }
}

async function init(){
  try {
    ui.status.textContent = 'Loading live layers…';
    const [wifi,play,parks,fields,splash,bldg,roads,pemu,land] = await Promise.all([
      fetchAllArcGISGeoJSON(URLS.wifi),
      fetchAllArcGISGeoJSON(URLS.play),
      fetchAllArcGISGeoJSON(URLS.parks),
      fetchAllArcGISGeoJSON(URLS.fields),
      fetchAllArcGISGeoJSON(URLS.splash),
      fetchAllArcGISGeoJSON(URLS.bldg),
      fetchAllArcGISGeoJSON(URLS.roads),
      fetchAllArcGISGeoJSON(URLS.pemu),
      fetchAllArcGISGeoJSON(URLS.land)
    ]);

    const amenities = {
      type:'FeatureCollection',
      features: []
        .concat(play.features)
        .concat(parks.features.map(f=>turf.centroid(f)))
        .concat(fields.features.map(f=>turf.centroid(f)))
        .concat(splash.features)
    };
    const bldgCentroids = { type:'FeatureCollection', features: bldg.features.map(f=>turf.centroid(f)) };
  
    LAYERS = {
      wifi,
      play,            // <-- keep raw playground points
      parks,           // <-- parks polygons
      fields,          // <-- fields polygons
      splash,          // <-- splash parks (points)
      amenities,       // merged points for scoring only
      bldgPolys: bldg,
      bldgCentroids,
      roads,
      pemu,
      land
    };

    try { const bb = turf.bbox(land); map.fitBounds([[bb[1],bb[0]],[bb[3],bb[2]]], {padding:[15,15]}); } catch {}

    // --- Build overlay display layers and expose for toggles ---
    const overlay = {
      layerWifi  : L.geoJSON(LAYERS.wifi,  {
        pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:5,weight:1,color:'#016797',fillOpacity:0.8})
      }).bindTooltip('Wi-Fi'),
    
      layerPlay  : L.geoJSON(LAYERS.play,  {  // Playgrounds (points)
        pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:4,weight:1,color:'#0099cb',fillOpacity:0.9})
      }).bindTooltip('Playground'),
    
      layerParks : L.geoJSON(LAYERS.parks, {  // Parks (polygons)
        style:()=>({color:'#2e7d32', weight:1, fillColor:'#a5d6a7', fillOpacity:0.25})
      }).bindTooltip('Park'),
    
      layerFields: L.geoJSON(LAYERS.fields,{  // Playing fields (polygons)
        style:()=>({color:'#1b5e20', weight:1, fillColor:'#c8e6c9', fillOpacity:0.25})
      }).bindTooltip('Playing Field'),
    
      layerSplash: L.geoJSON(LAYERS.splash,{  // Splash Parks (points)
        pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:4,weight:1,color:'#0aa2ff',fillOpacity:0.9})
      }).bindTooltip('Splash Park'),
    
      layerRoads : L.geoJSON(LAYERS.roads, {  // Roads (lines)
        style:()=>({color:'#a16d00', weight:1})
      }),
    
      layerBldg  : L.geoJSON(LAYERS.bldgPolys, {
        style:()=>({color:'#444', weight:0.8, fillColor:'#bbb', fillOpacity:0.3})
      }),
    
      layerPEMU  : L.geoJSON(LAYERS.pemu, {
        style:()=>({color:'#6a0080', weight:1.2, fillColor:'#dcb6ef', fillOpacity:0.25})
      }).bindTooltip('Priority Env. Mgmt Unit'),
    
      layerLand  : L.geoJSON(LAYERS.land, {   // Land-use polygons (display tint)
        style: f => {
          const {score} = landUseScoreAndLabel(f.properties||{});
          const t = (score - 0.4) / (0.9 - 0.4);
          return { color:'#666', weight:0.5, fillColor:`hsl(${210-160*Math.max(0,Math.min(1,t))},60%,70%)`, fillOpacity:0.35 };
        },
        onEachFeature:(f,lyr)=> {
          const det = landUseScoreAndLabel(f.properties||{});
          lyr.bindPopup(`<b>Land-use</b>: ${det.label}<br><b>Score:</b> ${det.score}`);
        }
      })
    };
    window._overlayLayers = overlay;


    // helper to wire a checkbox to a layer (and apply initial state)
    function bindToggle(id, layer){
      const el = document.getElementById(id);
      if (!el) return;
      if (el.checked) { layer.addTo(map); layer.bringToFront?.(); }
      el.addEventListener('change', e => {
        if (e.target.checked) { layer.addTo(map); layer.bringToFront?.(); }
        else { map.removeLayer(layer); }
      });
    }
    bindToggle('toggleWifi',   overlay.layerWifi);
    bindToggle('togglePlay',   overlay.layerPlay);
    bindToggle('toggleRoads',  overlay.layerRoads);
    bindToggle('toggleBldg',   overlay.layerBldg);
    bindToggle('togglePEMU',   overlay.layerPEMU);
    bindToggle('toggleLand',   overlay.layerLand);
    bindToggle('toggleParks',  overlay.layerParks);
    bindToggle('toggleFields', overlay.layerFields);
    bindToggle('toggleSplash', overlay.layerSplash);

    // PurpleAir toggle
    ui.togglePA.addEventListener('change', async (e) => {
      if (e.target.checked) {
        if (!paLayer) paLayer = await buildExternalPointsLayer(LAYER_URLS.purpleair, { color:'#7a1fa2', label:'PurpleAir' });
        paLayer && paLayer.addTo(map).bringToFront();
      } else {
        paLayer && map.removeLayer(paLayer);
      }
    });

    // Stations toggle (from data.js)
    ui.toggleStations.addEventListener('change', async (e) => {
      if (e.target.checked) {
        if (!stnLayer) stnLayer = await buildStationsLayer();
        stnLayer.addTo(map).bringToFront();
      } else {
        stnLayer && map.removeLayer(stnLayer);
      }
    });

    ui.status.textContent = 'Ready. Click Recompute.';
  } catch (e) {
    console.error(e);
    ui.status.innerHTML = `<span class="err">Failed to load data: ${e.message}</span>`;
  }
}

/* -------------- Build external points layer (for PurpleAir) ------- */
async function buildExternalPointsLayer(url, style={}) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    let json; try { json = JSON.parse(text); } catch { throw new Error('Invalid JSON'); }

    let fc = null;
    if (json && json.type === 'FeatureCollection' && Array.isArray(json.features)) fc = json;
    else if (Array.isArray(json)) fc = arrayToFeatureCollection(json);
    else if (json && json.data && Array.isArray(json.data)) fc = arrayToFeatureCollection(json.data);
    else if (json && json.features) fc = { type:'FeatureCollection', features: json.features };
    else fc = arrayToFeatureCollection(Object.values(json));

    return L.geoJSON(fc, {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: 4, weight: 1.5, color: style.color || '#333', fillColor: '#fff', fillOpacity: 1
      }).bindTooltip(f.properties && (f.properties.name || f.properties.label || f.properties.id || style.label) || style.label || '', {direction:'top', offset:[0,-6]})
    });
  } catch (err) {
    console.error('Failed to load', style.label||'layer', err);
    alert(`Failed to load ${style.label||'layer'}: ${err.message}`);
    return null;
  }
}
function arrayToFeatureCollection(arr) {
  const latKeys = ['lat','latitude','Latitude','LAT','Lat'];
  const lonKeys = ['lon','lng','long','longitude','Longitude','LON','Lng'];
  const nameKeys = ['name','Name','label','Label','station','Station','title','Title','id','ID'];
  const feats = [];
  for (const row of arr) {
    const latK = latKeys.find(k => k in row);
    const lonK = lonKeys.find(k => k in row);
    if (!latK || !lonK) continue;
    const nameK = nameKeys.find(k => k in row);
    feats.push({ type:'Feature', properties:{...(row||{}), name: nameK ? row[nameK] : undefined}, geometry:{ type:'Point', coordinates:[+row[lonK], +row[latK]] }});
  }
  return { type:'FeatureCollection', features:feats };
}

/* --------------------------- SCORING ------------------------------ */
function recompute(){
  if (!LAYERS.land) { ui.status.innerHTML = '<span class="warn">Data not loaded yet…</span>'; return; }
  ui.status.innerHTML = '<span class="muted">Computing…</span>';

  // Optional: honor toggles after layers are created
  if (hexLayer && ui.toggleHex && !ui.toggleHex.checked) map.removeLayer(hexLayer);
  if (topLayer && ui.toggleTop && !ui.toggleTop.checked) map.removeLayer(topLayer);

  const cellKm = +ui.cellkm.value;
  const dMax   = +ui.dmax.value;
  const mode   = ui.mode.value;
  const roadsPref = ui.roadsPref.value;
  const excludePEMU = ui.excludePEMU.checked;

  // weights normalized
  let w = { wifi:+ui.w_wifi.value, amen:+ui.w_amen.value, road:+ui.w_road.value, lu:+ui.w_lu.value, bld:+ui.w_bld.value };
  const sum = Object.values(w).reduce((a,b)=>a+b,0) || 1;
  Object.keys(w).forEach(k => w[k]=w[k]/sum);

  const { wifi, amenities, bldgCentroids, roads, pemu, land } = LAYERS;

  // hex grid over land-use bbox
  const bbox = turf.bbox(land);
  const hex = turf.hexGrid(bbox, cellKm, { units:'kilometers' });

  const raw = [];
  let maxBldDen = 0;

  for (const cell of hex.features) {
    const center = turf.centerOfMass(cell);

    const dWifi = distanceToFeaturesKm(center, wifi);
    const dAmen = distanceToFeaturesKm(center, amenities);
    const dRoad = distanceToRoadsKm(center, roads);

    const ring = turf.circle(center, 0.1, {steps:16, units:'kilometers'});
    const dens = turf.pointsWithinPolygon(bldgCentroids, ring).features.length;
    if (dens > maxBldDen) maxBldDen = dens;

    const luDet = landUseAtPointWithDetails(center, land);

    // constraint FIRST
    let allowed = 1;
    if (excludePEMU && pointInAnyPolygon(center, pemu)) allowed = 0;

    raw.push({ cell, center, dWifi, dAmen, dRoad, dens, luScore: luDet.score, luLabel: luDet.label, allowed });
  }

  // scale & combine
  const denMax = Math.max(1, maxBldDen);
  for (const r of raw) {
    const s_wifi = clamp(1 - (r.dWifi / dMax), 0, 1);
    const s_amen = (mode === 'exposure') ? clamp(1 - (r.dAmen / dMax),0,1)
                                         : clamp(  (r.dAmen / dMax),0,1);
    const s_road = (roadsPref === 'closer') ? clamp(1 - (r.dRoad / dMax),0,1)
                                            : clamp(  (r.dRoad / dMax),0,1);
    const s_bld  = clamp(r.dens / denMax, 0, 1);
    const s_lu   = clamp(r.luScore, 0, 1);

    r.scoreRaw = w.wifi*s_wifi + w.amen*s_amen + w.road*s_road + w.lu*s_lu + w.bld*s_bld;
    r.score    = r.scoreRaw * r.allowed;
  }

  const minS = Math.min(...raw.map(r=>r.score));
  const maxS = Math.max(...raw.map(r=>r.score));
  function colorFor(s){
    const t = (s - minS) / (maxS - minS + 1e-9);
    return `hsl(${200 - 160*t}, ${30 + 40*t}%, ${85 - 45*t}%)`;
  }

  // paint hexes
  hex.features.forEach((f,i)=>{
    const r = raw[i];
    f.properties = { score:+r.score.toFixed(3), lu_score:+r.luScore.toFixed(2), lu_label:r.luLabel };
  });
  if (hexLayer) map.removeLayer(hexLayer);
  hexLayer = L.geoJSON(hex, {
    pane: 'suitability',
    style: f => ({ color:'#aaa', weight:0.4, fillColor: colorFor(f.properties.score), fillOpacity: 0.78 })
  }).addTo(map);
  
  topLayer = L.geoJSON(topFC, {
    pane: 'markers',
    pointToLayer: (f, ll) => L.circleMarker(ll, { radius:6, weight:2, color:'#fe0002', fillColor:'#fff', fillOpacity:1 })
  }).addTo(map);
  if (ui.toggleHex && !ui.toggleHex.checked) map.removeLayer(hexLayer);

  // top 10
  const sorted = raw.filter(r=>r.allowed===1).sort((a,b)=>b.score-a.score).slice(0,10);
  const topFC = { type:'FeatureCollection', features: sorted.map(r=>({ type:'Feature', properties:{score:+r.score.toFixed(3)}, geometry:r.center.geometry }))};
  if (topLayer) map.removeLayer(topLayer);
  topLayer = L.geoJSON(topFC, {
    pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:6,weight:2,color:'#fe0002',fillColor:'#fff',fillOpacity:1})
      .bindPopup(`<b>Candidate</b><br>Score: ${f.properties.score}`)
  }).addTo(map);
  topLayer.bringToFront();
  if (ui.toggleTop && !ui.toggleTop.checked) map.removeLayer(topLayer);

  ui.status.innerHTML = `<span class="ok">Done. Cells: ${hex.features.length}, Top10 shown.</span>`;
  ui.lu_readout.textContent = '—';
}

/* --------------------------- HELPERS ------------------------------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function centroidOrPoint(f) { const g = f.geometry; if (!g) return null; return g.type === 'Point' ? f : turf.centroid(f); }
function distanceToFeaturesKm(pt, fc){
  if (!fc.features.length) return 999;
  let min = Infinity;
  for (const f of fc.features) {
    const pf = centroidOrPoint(f); if (!pf) continue;
    const d = turf.distance(pt, pf, {units:'kilometers'});
    if (d < min) min = d;
  }
  return min;
}
function distanceToRoadsKm(pt, fc){
  if (!fc.features.length) return 999;
  let min = Infinity;
  for (const f of fc.features) {
    const g = f.geometry; if (!g) continue;
    if (g.type === 'LineString' || g.type === 'MultiLineString') {
      const d = turf.pointToLineDistance(pt, f, {units:'kilometers'});
      if (d < min) min = d;
    } else {
      const d = turf.distance(pt, centroidOrPoint(f), {units:'kilometers'});
      if (d < min) min = d;
    }
  }
  return min;
}
function pointInAnyPolygon(pt, polysFC){ for (const f of polysFC.features) if (turf.booleanPointInPolygon(pt, f)) return true; return false; }

/* --------------------------- WIRE UP ------------------------------- */
ui.runBtn.addEventListener('click', recompute);
init();
</script>
</body>
</html>
