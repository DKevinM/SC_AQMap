<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Rapid Suitability (MCDA-lite) — Strathcona County</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <style>
    :root { --panel-w: 320px; --fs: 11px; }
    html, body { height:100%; margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto; font-size:var(--fs); }
    #app {
      display:grid; grid-template-columns:1fr var(--panel-w); grid-template-rows:100vh; width:100vw; overflow:hidden;
    }
    #map { min-width:0; height:100%; }
    #panel {
      height:100%; overflow:auto; padding:8px 10px; border-left:1px solid #ddd; background:#fff; line-height:1.32; z-index:10000;
      display:flex; flex-direction:column;
    }
    h2 { font-size:12px; margin:2px 0 8px; }
    .small { color:#555; font-size:10px; }
    .group { margin:8px 0; }
    label { display:block; margin-bottom:4px; font-weight:600; }
    .row { display:flex; gap:6px; align-items:center; }
    input[type="range"] { width:100%; }
    select, input[type="checkbox"] { font-size:var(--fs); }
    .btn { display:inline-block; padding:5px 5px; background:#016797; color:#fff; border-radius:7px; cursor:pointer; text-decoration:none; }
    .badge { font-size:11px; background:#f0f0f0; padding:1px 5px; border-radius:999px; }
    .muted { color:#777; }
    .ok { color:#0a7; }
    .warn { color:#d70; }
    .err { color:#d33; }
    .hr { height:1px; background:#eee; margin:8px 0; }
    .legend { display:flex; height:10px; margin:4px 0 6px; background:linear-gradient(90deg,#fff7bf,#79bcd7,#0b3c73); border:1px solid #ccc; }
    /* footer readout fixed at bottom of panel */
    .footer { margin-top:auto; padding-top:8px; border-top:1px dashed #e5e5e5; }
  </style>
</head>
<body>
<div id="app">
  <div id="map"></div>

  <aside id="panel">
    <h2>Rapid Suitability (MCDA-lite)</h2>
    <div class="small">Hex-grid scoring from live ArcGIS GeoJSON. Adjust and click <b>Recompute</b>.</div>

    <div class="group">
      <label>Objective</label>
      <select id="mode">
        <option value="exposure">Population/Exposure (closer to amenities)</option>
        <option value="background">Background/Regional (farther from amenities)</option>
      </select>
    </div>

    <div class="group">
      <label>Roads preference</label>
      <select id="roadsPref">
        <option value="closer">Closer is better (near traffic)</option>
        <option value="farther">Farther is better (background)</option>
      </select>
    </div>

    <div class="group">
      <label>Hex cell size (km)</label>
      <div class="row">
        <input type="range" id="cellkm" min="0.3" max="2.5" step="0.1" value="0.6">
        <span id="cellkm_val" class="badge">0.6</span>
      </div>
    </div>

    <div class="group">
      <label>Distance cap for proximity (km) <span class="small">(linear rescale)</span></label>
      <div class="row">
        <input type="range" id="dmax" min="0.5" max="6" step="0.5" value="3">
        <span id="dmax_val" class="badge">3</span>
      </div>
    </div>

    <div class="group">
      <label>Weights (auto-normalize)</label>
      <div class="row"><span class="small" style="width:110px">Wi-Fi proximity</span><input type="range" id="w_wifi" min="0" max="1" step="0.05" value="0.25"><span id="w_wifi_val" class="badge">0.25</span></div>
      <div class="row"><span class="small" style="width:110px">Amenities proximity</span><input type="range" id="w_amen" min="0" max="1" step="0.05" value="0.25"><span id="w_amen_val" class="badge">0.25</span></div>
      <div class="row"><span class="small" style="width:110px">Roads proximity</span><input type="range" id="w_road" min="0" max="1" step="0.05" value="0.20"><span id="w_road_val" class="badge">0.20</span></div>
      <div class="row"><span class="small" style="width:110px">Land-use score</span><input type="range" id="w_lu" min="0" max="1" step="0.05" value="0.20"><span id="w_lu_val" class="badge">0.20</span></div>
      <div class="row"><span class="small" style="width:110px">Bldg density</span><input type="range" id="w_bld" min="0" max="1" step="0.05" value="0.10"><span id="w_bld_val" class="badge">0.10</span></div>
      <div class="small muted">Sum is normalized to 1.</div>
    </div>

    <div class="group">
      <label><input type="checkbox" id="excludePEMU"> Exclude inside Priority Environmental Mgmt Units</label>
    </div>

    <!-- LAYERS: click on/off -->
    <div class="group">
      <label>Layers (click to show/hide)</label>
      <div class="small">
        <label><input type="checkbox" id="toggleHex" checked> Suitability hexes</label><br>
        <label><input type="checkbox" id="toggleTop" checked> Top 10 candidates</label><br>
        <label><input type="checkbox" id="toggleWifi"> Buildings with Wi-Fi</label><br>
        <label><input type="checkbox" id="togglePlay"> Playgrounds</label><br>
        <label><input type="checkbox" id="toggleParks"> Parks</label><br>
        <label><input type="checkbox" id="toggleFields"> Playing Fields</label><br>
        <label><input type="checkbox" id="toggleSplash"> Splash Parks</label><br>
        <label><input type="checkbox" id="toggleRoads"> Roads</label><br>
        <label><input type="checkbox" id="toggleBldg"> Building footprints</label><br>
        <label><input type="checkbox" id="togglePEMU"> Priority Env. Mgmt Units</label><br>
        <label><input type="checkbox" id="toggleLand"> Land-use polygons</label><br>
        <label><input type="checkbox" id="togglePA"> PurpleAir sensors</label><br>
        <label><input type="checkbox" id="toggleStations"> AQ stations</label>
      </div>
    </div>
    
    <!-- Land-use score legend/explanation -->
    <div class="group small">
      <b>Land-use score mapping</b>
      <table style="font-size:11px;border-collapse:collapse;margin-top:4px">
        <tr><td>Industrial (IND)</td><td style="padding-left:8px">0.90</td></tr>
        <tr><td>Commercial (COM)</td><td style="padding-left:8px">0.80</td></tr>
        <tr><td>Institutional (INS)</td><td style="padding-left:8px">0.75</td></tr>
        <tr><td>Residential (RES)</td><td style="padding-left:8px">0.60</td></tr>
        <tr><td>Park / Open Space</td><td style="padding-left:8px">0.40</td></tr>
        <tr><td>Agriculture</td><td style="padding-left:8px">0.50</td></tr>
        <tr><td>Default/Other</td><td style="padding-left:8px">0.50</td></tr>
      </table>
    </div>

    <div class="group">
      <a id="runBtn" class="btn">Recompute</a>
      <span id="status" class="small muted">Loading data…</span>
    </div>

    <div class="group">
      <div class="small"><b>Legend</b> (low → high)</div>
      <div class="legend"></div>
    </div>

    <div class="hr"></div>
    <div class="small">
      Notes: Uses Wi-Fi bldgs, amenities (Playgrounds, Parks, Playing Fields, Splash Parks), Roads, Land-Use, and Building Footprints. Contours are ignored (no slope inference here).
    </div>

    <!-- NEW: Land-use score readout at panel bottom -->
    <div class="footer small">
      <b>Land-use score here:</b> <span id="lu_readout">—</span>
    </div>
  </aside>
</div>

<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script src="data.js"></script> 
  
<script>
/* ------------------------- CONFIG / LAYERS ------------------------- */
const URLS = {
  wifi:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/County_Buildings_with_WiFi/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  play:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Playgrounds/FeatureServer/3/query?outFields=*&where=1%3D1&f=geojson',
  parks: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Parks/FeatureServer/2/query?outFields=*&where=1%3D1&f=geojson',
  fields:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Playing_Fields/FeatureServer/5/query?outFields=*&where=1%3D1&f=geojson',
  splash:'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Splash_Parks/FeatureServer/8/query?outFields=*&where=1%3D1&f=geojson',
  bldg:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Building_Footprints/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  roads: 'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Street_Network1/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  pemu:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Priority_Environment_Management_Units/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson',
  land:  'https://services.arcgis.com/B7ZrK1Hv4P1dsm9R/arcgis/rest/services/Land_Use_Bylaw/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson'
};

// NEW: External point layers (PurpleAir + your stations)
const LAYER_URLS = {
  purpleair: 'https://raw.githubusercontent.com/DKevinM/AB_datapull/main/data/ACA_PM25_map.json',
  // TODO: set this to your stations JSON/GeoJSON (or a CSV converted to JSON)
  stations:  ''  // e.g., 'https://raw.githubusercontent.com/DKevinM/AB_datapull/main/data/AQHI_stations.geojson'
};

const markerGroup = L.layerGroup(); 
overlayLayers["Stations"] = markerGroup;

  
// Land-use mapping (unchanged)
function landUseScoreAndLabel(props) {
  const raw = (props.ZONE || props.DISTRICT || props.LAND_USE || props.LANDUSE || props.Zoning || '').toString();
  const lut = [
    {match:/industrial|^ind$/i,   score:0.90, label:'Industrial'},
    {match:/commercial|^com$/i,   score:0.80, label:'Commercial'},
    {match:/institution/i,        score:0.75, label:'Institutional'},
    {match:/residential|^res$/i,  score:0.60, label:'Residential'},
    {match:/park|open ?space/i,   score:0.40, label:'Park/Open Space'},
    {match:/agric/i,              score:0.50, label:'Agriculture'}
  ];
  for (const r of lut) if (r.match.test(raw)) return {score:r.score, label:r.label};
  return {score:0.50, label: raw || 'Default'};
}
function landUseAtPointWithDetails(pt, polysFC){
  for (const f of polysFC.features) {
    if (turf.booleanPointInPolygon(pt, f)) return landUseScoreAndLabel(f.properties||{});
  }
  if (!polysFC.features.length) return {score:0.5, label:'(no polygons)'};
  // fallback to nearest polygon
  let best = {score:0.5, label:'Nearest poly'}, min = Infinity;
  for (const f of polysFC.features) {
    const d = turf.distance(pt, turf.centroid(f), {units:'kilometers'});
    if (d < min) { min = d; best = landUseScoreAndLabel(f.properties||{}); }
  }
  return best;
}

/* --------------------------- UI / MAP ------------------------------ */
const map = L.map('map').setView([53.53, -113.30], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20}).addTo(map);
setTimeout(() => map.invalidateSize(), 0);
window.addEventListener('resize', () => map.invalidateSize());

const ui = {
  mode: document.getElementById('mode'),
  roadsPref: document.getElementById('roadsPref'),
  cellkm: document.getElementById('cellkm'),
  cellkm_val: document.getElementById('cellkm_val'),
  dmax: document.getElementById('dmax'),
  dmax_val: document.getElementById('dmax_val'),
  w_wifi: document.getElementById('w_wifi'),
  w_wifi_val: document.getElementById('w_wifi_val'),
  w_amen: document.getElementById('w_amen'),
  w_amen_val: document.getElementById('w_amen_val'),
  w_road: document.getElementById('w_road'),
  w_road_val: document.getElementById('w_road_val'),
  w_lu: document.getElementById('w_lu'),
  w_lu_val: document.getElementById('w_lu_val'),
  w_bld: document.getElementById('w_bld'),
  w_bld_val: document.getElementById('w_bld_val'),
  excludePEMU: document.getElementById('excludePEMU'),
  togglePA: document.getElementById('togglePA'),
  toggleStations: document.getElementById('toggleStations'),
  runBtn: document.getElementById('runBtn'),
  status: document.getElementById('status'),
  lu_readout: document.getElementById('lu_readout')
};
function hookRange(inp, lab){ const f=()=>lab.textContent=(+inp.value).toFixed(inp.step.includes('.')?1:0); inp.addEventListener('input',f); f(); }
[['cellkm','cellkm_val'],['dmax','dmax_val'],['w_wifi','w_wifi_val'],['w_amen','w_amen_val'],['w_road','w_road_val'],['w_lu','w_lu_val'],['w_bld','w_bld_val']].forEach(([a,b])=>hookRange(ui[a],ui[b]));

/* --------------------------- DATA LOAD ---------------------------- */
async function fetchAllArcGISGeoJSON(baseUrl, chunk=2000){
  const sep = baseUrl.includes('?') ? '&' : '?'; let offset = 0, all = [];
  while (true) {
    const url = `${baseUrl}${sep}resultOffset=${offset}&resultRecordCount=${chunk}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const gj = await res.json();
    const feats = gj.features || [];
    all = all.concat(feats);
    if (feats.length < chunk) break;
    offset += feats.length;
  }
  return { type:'FeatureCollection', features:all };
}

let LAYERS = {};
let hexLayer, topLayer;
// NEW: overlay groups
let paLayer = null, stnLayer = null;

async function init(){
  try {
    ui.status.textContent = 'Loading live layers…';
    const [wifi,play,parks,fields,splash,bldg,roads,pemu,land] = await Promise.all([
      fetchAllArcGISGeoJSON(URLS.wifi),
      fetchAllArcGISGeoJSON(URLS.play),
      fetchAllArcGISGeoJSON(URLS.parks),
      fetchAllArcGISGeoJSON(URLS.fields),
      fetchAllArcGISGeoJSON(URLS.splash),
      fetchAllArcGISGeoJSON(URLS.bldg),
      fetchAllArcGISGeoJSON(URLS.roads),
      fetchAllArcGISGeoJSON(URLS.pemu),
      fetchAllArcGISGeoJSON(URLS.land)
    ]);

    const amenities = {
      type:'FeatureCollection',
      features: []
        .concat(play.features)
        .concat(parks.features.map(f=>turf.centroid(f)))
        .concat(fields.features.map(f=>turf.centroid(f)))
        .concat(splash.features)
    };
    const bldgCentroids = { type:'FeatureCollection', features: bldg.features.map(f=>turf.centroid(f)) };

    LAYERS = { wifi, amenities, bldgPolys: bldg, bldgCentroids, roads, pemu, land };

    try { const bb = turf.bbox(land); map.fitBounds([[bb[1],bb[0]],[bb[3],bb[2]]], {padding:[15,15]}); } catch {}

    // --- Build visual Leaflet layers for toggling ---
    let layerWifi   = L.geoJSON(LAYERS.wifi,  { pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:5,weight:1,color:'#016797',fillOpacity:0.8}).bindPopup('Wi-Fi building') });
    let layerPlay   = L.geoJSON(LAYERS.amenities, { pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:4,weight:1,color:'#0099cb',fillOpacity:0.7}).bindPopup('Amenity') });
    let layerRoads  = L.geoJSON(LAYERS.roads, { style:()=>({color:'#a16d00', weight:1}) });
    let layerBldg   = L.geoJSON(LAYERS.bldgPolys, { style:()=>({color:'#444', weight:0.8, fillColor:'#bbb', fillOpacity:0.3}) });
    let layerPEMU   = L.geoJSON(LAYERS.pemu, { style:()=>({color:'#6a0080', weight:1.2, fillColor:'#dcb6ef', fillOpacity:0.25}) })
                        .bindTooltip('Priority Env. Mgmt Unit');
    let layerLand   = L.geoJSON(LAYERS.land, {
      style: f => {
        // tint by land-use score (not used for MCDA color—just a display layer)
        const {score} = landUseScoreAndLabel(f.properties||{});
        const t = (score - 0.4) / (0.9 - 0.4);
        return { color:'#666', weight:0.5, fillColor:`hsl(${210-160*Math.max(0,Math.min(1,t))},60%,70%)`, fillOpacity:0.35 };
      },
      onEachFeature: (f, lyr) => {
        const det = landUseScoreAndLabel(f.properties||{});
        lyr.bindPopup(`<b>Land-use</b>: ${det.label}<br><b>Score:</b> ${det.score}`);
      }
    });
    
    // keep refs so toggles can access them
    window._overlayLayers = { layerWifi, layerPlay, layerRoads, layerBldg, layerPEMU, layerLand };

    
    // wire overlay toggles
    ui.togglePA.addEventListener('change', async (e) => {
      if (e.target.checked) {
        if (!paLayer) paLayer = await buildExternalPointsLayer(LAYER_URLS.purpleair, { color:'#7a1fa2', label:'PurpleAir' });
        paLayer && paLayer.addTo(map).bringToFront();
      } else {
        paLayer && map.removeLayer(paLayer);
      }
    });
    ui.toggleStations.addEventListener('change', async (e) => {
      if (e.target.checked) {
        if (!stnLayer) {
          if (!LAYER_URLS.stations) {
            alert('Set LAYER_URLS.stations to your stations JSON/GeoJSON URL.');
            e.target.checked = false; return;
          }
          stnLayer = await buildExternalPointsLayer(LAYER_URLS.stations, { color:'#0b62a4', label:'Station' });
        }
        stnLayer && stnLayer.addTo(map).bringToFront();
      } else {
        stnLayer && map.removeLayer(stnLayer);
      }
    });

    ui.status.textContent = 'Ready. Click Recompute.';
  } catch (e) {
    console.error(e);
    ui.status.innerHTML = `<span class="err">Failed to load data: ${e.message}</span>`;
  }
}

/* -------------- Build external points layer (robust parser) ------- */
async function buildExternalPointsLayer(url, style={}) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();

    // try JSON parse
    let json;
    try { json = JSON.parse(text); }
    catch { throw new Error('Invalid JSON'); }

    let fc = null;

    // If already GeoJSON FeatureCollection
    if (json && json.type === 'FeatureCollection' && Array.isArray(json.features)) {
      fc = json;
    } else if (Array.isArray(json)) {
      fc = arrayToFeatureCollection(json);
    } else if (json && json.data && Array.isArray(json.data)) {
      fc = arrayToFeatureCollection(json.data);
    } else if (json && json.features) {
      fc = { type:'FeatureCollection', features: json.features };
    } else {
      // last resort: try to detect single-object map
      fc = arrayToFeatureCollection(Object.values(json));
    }

    const layer = L.geoJSON(fc, {
      pointToLayer: (f, latlng) => L.circleMarker(latlng, {
        radius: 4,
        weight: 1.5,
        color: style.color || '#333',
        fillColor: '#fff',
        fillOpacity: 1
      }).bindTooltip(f.properties && (f.properties.name || f.properties.label || f.properties.id || style.label) || style.label || '', {direction:'top', offset:[0,-6]})
    });

    return layer;
  } catch (err) {
    console.error('Failed to build points layer for', url, err);
    alert(`Failed to load ${style.label||'layer'}: ${err.message}`);
    return null;
  }
}

// Convert array of rows with lat/lon-ish keys to FeatureCollection
function arrayToFeatureCollection(arr) {
  const latKeys = ['lat','latitude','Latitude','LAT','Lat'];
  const lonKeys = ['lon','lng','long','longitude','Longitude','LON','Lng'];
  const nameKeys = ['name','Name','label','Label','station','Station','title','Title','id','ID'];

  const feats = [];
  for (const row of arr) {
    const latK = latKeys.find(k => k in row);
    const lonK = lonKeys.find(k => k in row);
    if (!latK || !lonK) continue;
    const nameK = nameKeys.find(k => k in row);
    feats.push({
      type:'Feature',
      properties: { ...(row||{}), name: nameK ? row[nameK] : undefined },
      geometry: { type:'Point', coordinates:[ +row[lonK], +row[latK] ] }
    });
  }
  return { type:'FeatureCollection', features:feats };
}

/* --------------------------- SCORING ------------------------------ */
function recompute(){
  if (!LAYERS.land) { ui.status.innerHTML = '<span class="warn">Data not loaded yet…</span>'; return; }
  ui.status.innerHTML = '<span class="muted">Computing…</span>';

  // connect to toggles (keep default checked)
  const toggleHex = document.getElementById('toggleHex');
  const toggleTop = document.getElementById('toggleTop');
  if (toggleHex && !toggleHex.checked) map.removeLayer(hexLayer);
  if (toggleTop && !toggleTop.checked) map.removeLayer(topLayer);
  if (toggleHex) toggleHex.onchange = e => e.target.checked ? hexLayer.addTo(map) : map.removeLayer(hexLayer);
  if (toggleTop) toggleTop.onchange = e => e.target.checked ? topLayer.addTo(map).bringToFront() : map.removeLayer(topLayer);

  const cellKm = +ui.cellkm.value;
  const dMax   = +ui.dmax.value;
  const mode   = ui.mode.value;
  const roadsPref = ui.roadsPref.value;
  const excludePEMU = ui.excludePEMU.checked;

  // Weights normalized
  let w = {
    wifi:+ui.w_wifi.value, amen:+ui.w_amen.value, road:+ui.w_road.value, lu:+ui.w_lu.value, bld:+ui.w_bld.value
  };
  const sum = Object.values(w).reduce((a,b)=>a+b,0) || 1;
  Object.keys(w).forEach(k => w[k]=w[k]/sum);

  const { wifi, amenities, bldgCentroids, roads, pemu, land } = LAYERS;

  // Hex grid over land-use bbox
  const bbox = turf.bbox(land);
  const hex = turf.hexGrid(bbox, cellKm, { units:'kilometers' });

  // For each hex center compute criteria
  const raw = [];
  let maxBldDen = 0;
  for (const cell of hex.features) {
    const center = turf.centerOfMass(cell);

    const dWifi = distanceToFeaturesKm(center, wifi);
    const dAmen = distanceToFeaturesKm(center, amenities);
    const dRoad = distanceToRoadsKm(center, roads);

    const ring = turf.circle(center, 0.1, {steps:16, units:'kilometers'});
    const dens = turf.pointsWithinPolygon(bldgCentroids, ring).features.length;
    if (dens > maxBldDen) maxBldDen = dens;

    // was: const lu = landUseAtPoint(center, land);
    const luDet = landUseAtPointWithDetails(center, land);
    raw.push({ cell, center, dWifi, dAmen, dRoad, dens, luScore: luDet.score, luLabel: luDet.label, allowed });

    let allowed = 1;
    if (excludePEMU && pointInAnyPolygon(center, pemu)) allowed = 0;

    raw.push({ cell, center, dWifi, dAmen, dRoad, dens, lu, allowed });
  }

  // Scale 0–1 and combine
  const denMax = Math.max(1, maxBldDen);
  for (const r of raw) {
    const s_wifi = clamp(1 - (r.dWifi / dMax), 0, 1);
    const s_amen = (mode === 'exposure') ? clamp(1 - (r.dAmen / dMax),0,1)
                                         : clamp(  (r.dAmen / dMax),0,1);
    const s_road = (roadsPref === 'closer') ? clamp(1 - (r.dRoad / dMax),0,1)
                                            : clamp(  (r.dRoad / dMax),0,1);
    const s_bld  = clamp(r.dens / denMax, 0, 1);
    const s_lu = clamp(r.luScore, 0, 1);

    r.scoreRaw = w.wifi*s_wifi + w.amen*s_amen + w.road*s_road + w.lu*s_lu + w.bld*s_bld;
    r.score    = r.scoreRaw * r.allowed;
  }

  const minS = Math.min(...raw.map(r=>r.score));
  const maxS = Math.max(...raw.map(r=>r.score));
  function colorFor(s){
    const t = (s - minS) / (maxS - minS + 1e-9);
    return `hsl(${200 - 160*t}, ${30 + 40*t}%, ${85 - 45*t}%)`;
  }

  // Paint hexes (include lu for popup)
  hex.features.forEach((f,i)=>{
    const r = raw[i];
    f.properties = {
      score:+r.score.toFixed(3),
      lu_score:+r.luScore.toFixed(2),
      lu_label:r.luLabel
    };
  });
  hexLayer = L.geoJSON(hex, {
    style: f => ({ color:'#aaa', weight:0.4, fillColor:colorFor(f.properties.score), fillOpacity:0.78 }),
    onEachFeature:(f,lyr)=>{
      const p = f.properties;
      lyr.bindPopup(`<b>Suitability</b>: ${p.score}<br><b>Land-use:</b> ${p.lu_label} (score ${p.lu_score})`);
      lyr.on('click', () => { ui.lu_readout.textContent = `${p.lu_label} (${p.lu_score})`; });
    }
  }).addTo(map);

  // Top 10
  const sorted = raw.filter(r=>r.allowed===1).sort((a,b)=>b.score-a.score).slice(0,10);
  const topFC = { type:'FeatureCollection', features: sorted.map(r=>({
    type:'Feature', properties:{score:+r.score.toFixed(3)}, geometry:r.center.geometry
  }))};
  topLayer = L.geoJSON(topFC, {
    pointToLayer:(f,latlng)=>L.circleMarker(latlng,{radius:6,weight:2,color:'#fe0002',fillColor:'#fff',fillOpacity:1})
      .bindPopup(`<b>Candidate</b><br>Score: ${f.properties.score}`)
  }).addTo(map);
  topLayer.bringToFront();

  ui.status.innerHTML = `<span class="ok">Done. Cells: ${hex.features.length}, Top10 shown.</span>`;
  // reset footer on recompute
  ui.lu_readout.textContent = '—';
}

/* --------------------------- HELPERS ------------------------------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function centroidOrPoint(f) { const g = f.geometry; if (!g) return null; return g.type === 'Point' ? f : turf.centroid(f); }
function distanceToFeaturesKm(pt, fc){
  if (!fc.features.length) return 999;
  let min = Infinity;
  for (const f of fc.features) {
    const pf = centroidOrPoint(f); if (!pf) continue;
    const d = turf.distance(pt, pf, {units:'kilometers'});
    if (d < min) min = d;
  }
  return min;
}
function distanceToRoadsKm(pt, fc){
  if (!fc.features.length) return 999;
  let min = Infinity;
  for (const f of fc.features) {
    const g = f.geometry; if (!g) continue;
    if (g.type === 'LineString' || g.type === 'MultiLineString') {
      const d = turf.pointToLineDistance(pt, f, {units:'kilometers'});
      if (d < min) min = d;
    } else {
      const d = turf.distance(pt, centroidOrPoint(f), {units:'kilometers'});
      if (d < min) min = d;
    }
  }
  return min;
}
function landUseAtPoint(pt, polysFC){
  for (const f of polysFC.features) if (turf.booleanPointInPolygon(pt, f)) return landUseScore(f.properties||{});
  if (!polysFC.features.length) return 0.5;
  let best = 0.5, min = Infinity;
  for (const f of polysFC.features) {
    const d = turf.distance(pt, turf.centroid(f), {units:'kilometers'});
    if (d < min) { min = d; best = landUseScore(f.properties||{}); }
  }
  return best;
}
function pointInAnyPolygon(pt, polysFC){ for (const f of polysFC.features) if (turf.booleanPointInPolygon(pt, f)) return true; return false; }

/* --------------------------- WIRE UP ------------------------------- */
ui.runBtn.addEventListener('click', recompute);
init();

// helper to wire a checkbox to a layer
function bindToggle(id, layer){
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('change', e => {
    if (e.target.checked) { layer.addTo(map); layer.bringToFront?.(); }
    else { map.removeLayer(layer); }
  });
}
bindToggle('toggleWifi',   window._overlayLayers.layerWifi);
bindToggle('togglePlay',   window._overlayLayers.layerPlay);
bindToggle('toggleRoads',  window._overlayLayers.layerRoads);
bindToggle('toggleBldg',   window._overlayLayers.layerBldg);
bindToggle('togglePEMU',   window._overlayLayers.layerPEMU);
bindToggle('toggleLand',   window._overlayLayers.layerLand);

// Existing PurpleAir / Stations toggles already wired below in your code


  
</script>
</body>
</html>
